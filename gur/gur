#!/usr/bin/env bash

# SPDX-License-Identifier: AGPL-3.0-or-later

#    ----------------------------------------------------------------------
#    Copyright © 2024, 2025  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

_bin="$(
  dirname \
    "$(command \
        -v \
	  "env")")"
_lib="$(realpath \
    "${_bin}/../lib")"
_crash_bash="${_lib}/libcrash-bash/crash-bash"
_sourced \
  "${_crash_bash}" 2>/dev/null || \
  source \
    "${_crash_bash}"

# shellcheck disable=SC2034
_global_variables() {
  run_date=""
  wallet_name=""
  git_services=()
  git_services_amount=""
  target_namespaces=()
  target_command=""
  target_key=""
  target_value=""
  repo_type=""
  repo_name=""
  cache_dir=""
  http="https://github.com"
  mirror_description=(
    "Ur uncensorable DogeOS"
    "and Life user repository"
    "and app store package HTTP mirror."
  )
  mirror_homepage="${http}/themartiancompany/ur"
  mirror_topics=(
    "ur"
    "ur-app-store"
    "universal-recipe"
    "user-repo"
    "dogeos-package"
    "life-package"
  )
  mirror_fields=(
    "exists"
    "description"
    "homepage"
    "topics"
    "namespace_id"
    "project_id"
    "secrets"
    "artifacts"
    "ci"
    "env"
    "log"
    "quota"
    "releases"
    "release"
  )
  color=""
  quiet=""
}

_requirements() {
  _check_cmd \
    "cat" \
    "coreutils"
  _check_cmd \
    "curl"
  _check_cmd \
    "evm-gpg" \
    "evm-gnupg"
  _check_cmd \
    'gh'
  _check_cmd \
    'gl-dl'
  _check_cmd \
    'python'
  _check_cmd \
    'jq'
  _check_cmd \
    "recipe-get" \
    "reallymakepkg"
  _check_cmd \
    "sort" \
    "coreutils"
  _check_cmd \
    "tail" \
    "coreutils"
  _check_cmd \
    "unzip"
}

_get_conf_dir_path() {
  local \
    _dir
  _dir="${HOME}/.config/${app_name}"
  echo \
    "${_dir}"
}

_repos_get() {
  local \
    _namespace="${1}" \
    _service
  _service="github"
  if (( 1 < "${#}")); then
    _service="${2}"
  fi
  "_${_service}_repos_get" \
    "${_namespace}"
}

_github_gh_repos_get() {
  local \
    _namespace="${1}" \
    _namespace_active \
    _gh_opts=() \
    _repos_dir \
    _repos_file \
    _repos_names=() \
    _repos_names_private=() \
    _repos_array=() \
    _limit \
    _msg=() \
    _switch
  _repos_dir="${_cache_dir}/${_namespace}/github"
  _repos_file="${_repos_dir}/repos.db"
  _namespace_active="$(
    _github_account_active_get)"
  _switch="$(
    gh \
      auth \
        switch \
        -u \
          "${_namespace}" || \
    gh \
      auth \
        switch \
        -u \
          "${_namespace_active}")"
  _limit="314000000000"
  _gh_opts+=(
    --json
      "name"
    --limit
      "${_limit}"
    --jq
      ".[].name"
  )
  _gh_private_opts+=(
    --json
      "name"
    --limit
      "${_limit}"
    --json
      "name"
    --visibility
      "private"
    --json
      "isPrivate"
    --jq
      ".[]"
  )
  _repos_names_private+=( $(
    gh \
      repo \
      list \
      "${_namespace}" \
      "${_gh_private_opts[@]}")
  )
  _repos_names+=( $(
    gh \
      repo \
      list \
      "${_namespace}" \
      "${_gh_opts[@]}")
  )
  for _repo in "${_repos_names[@]}"; do
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  for _repo in "${_repos_names_private[@]}"; do
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  # if [[ -e "${_repos_file}" ]]; then
  #   _repos_array+=( $(
  #     cat \
  #       "${_repos_file}")
  #   )
  # fi
  _msg=(
    "Found '${#_repos_array[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _array_set \
    "_repos_array" \
    "_repos"
  mkdir \
    -p \
    "${_repos_dir}"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_repos_file}" || \
    true
}

_github_py_repos_get() {
  local \
    _namespace="${1}" \
    _url \
    _repo \
    _repos=() \
    _repos_array=() \
    _repos_file \
    _repos_get_bin \
    _repos_get_opts=() \
    _repos_urls=() \
    _lib \
    _msg=() \
    _token_private \
    _repos_local \
    _repos_dir
  _repos_dir="${_cache_dir}/${_namespace}/github"
  _repos_file="${_repos_dir}/repos.db"
  _lib="$(
    _get_lib)"
  _repos_get_bin="${_lib}/${app_name}/repos-get"
  _token_private_get \
    "github.com" \
    "${_namespace}"
  _repos_get_opts+=(
    --key
      "${_token_private}"
  )
  _msg=(
    "Retrieving list of"
    "Ur mirrors for"
    "'${_namespace}' namespace"
    "from Github."
  )
  _msg_info \
    "${_msg[*]}"
  _repos_urls=( $(
    "${_repos_get_bin}" \
      "${_repos_get_opts[@]}" \
      "${_namespace}")
  )
  for _url in "${_repos_urls[@]}"; do
    _repo="$(
      basename \
        "${_url}")"
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  if [[ -e "${_repos_file}" ]]; then
    _repos_array+=( $(
      cat \
        "${_repos_file}")
    )
  fi
  _msg=(
    "Found '${#_repos[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "Saving list locally"
    "because Github API limit"
    "is ridiculous for a company"
    "which gives people free computers"
    "to build stuff."
  )
  _msg_info \
    "${_msg[*]}"
  _array_set \
    "_repos_array" \
    "_repos"
  mkdir \
    -p \
    "${_repos_dir}"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_repos_file}" || \
    true
}


# List namespace repositories
# on Github
# $1: target namespace
# $2: retrieval mode, it can be
#     'gh' or 'py'
_github_repos_get() {
  local \
    _namespace="${1}" \
    _mode
  _mode="gh"
  if (( 1 < "${#}" )); then
    _mode="${2}"
  fi
  "_github_${_mode}_repos_get" \
    "${_namespace}"
}

_gitlab_repos_get() {
  local \
    _namespace="${1}" \
    _url \
    _repo \
    _repos=() \
    _repos_array=() \
    _repos_file \
    _repos_get_bin \
    _repos_get_opts=() \
    _repos_urls=() \
    _lib \
    _msg=() \
    _token \
    _token_private
  _repos_file="${_cache_dir}/${_namespace}/gitlab/repos.db"
  _token_private_get \
    "github.com" \
    "${_namespace}"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/namespaces"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _namespaces="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _msg=(
    "Retrieving list of"
    "Ur mirrors for"
    "'${_namespace}' namespace"
    "from Gitlab."
  )
  _msg_info \
    "${_msg[*]}"
  _repos_urls=( $(
    "${_repos_get_bin}" \
      "${_repos_get_opts[@]}" \
      "${_namespace}")
  )
  for _url in "${_repos_urls[@]}"; do
    _repo="$(
      basename \
        "${_url}")"
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  if [[ -e "${_repos_file}" ]]; then
    _repos_array+=( $(
      cat \
        "${_repos_file}" |
        sort \
          -V)
    )
  fi
  _array_set \
    "_repos_array" \
    "_repos"
  _msg=(
    "Found '${#_repos[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "Saving list locally"
    "because Github API limit"
    "is ridiculous for a company"
    "which gives people free computers"
    "to build stuff."
  )
  _msg_info \
    "${_msg[*]}"
  _array_set \
    "_repos_array" \
    "_repos"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_repos_file}"
}


_github_description_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description
  _description="$(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "description" \
      --jq \
        ".description")"
  echo \
    "${_description}"
}

_github_homepage_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _homepage="$(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "homepageUrl" \
      --jq \
        ".homepageUrl")"
  echo \
    "${_homepage}"
}

_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}"
  _github_secrets_get \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _gh_opts=() \
    _repo_url
  _repo_url="${http}/${_target_namespace}/${_target_repo}"
  _gh_opts+=(
    --repo
      "${_repo_url}"
  )
  _secrets=( $(
    gh \
      "${_gh_opts[@]}" \
      secret \
        list |
        awk \
          '{print $1}')
  )
  echo \
    "${_secrets[@]}"
}

_topics_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=()
  _topics=( $(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "repositoryTopics" \
      --jq \
        ".repositoryTopics.[].name" 2>/dev/null)
  )
  echo \
    "${_topics[@]}"
}

_github_description_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -d \
      "${_description}"
}

_github_homepage_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -h \
      "${_homepage}"
}

_github_topic_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topic="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    --add-topic \
      "${_topic}"
}

_project_id_check() {
  true
}

_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}"
  _github_description_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description \
    _msg=()
  _msg=(
    "Checking Github's"
    "'${_target_namespace}/${_target_repo}-ur'"
    "description."
  )
  _msg_info \
    "${_msg[*]}"
  _description="$(
    _github_description_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_description}" != "${mirror_description[*]}" ]]; then
    _github_description_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_description[*]}"
  fi
}

_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_homepage_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _msg=(
    "Checking"
    "'${_target_namespace}/${_target_repo}-ur'"
    "homepage."
  )
  _msg_info \
    "${_msg[*]}"
  _homepage="$(
    _homepage_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_homepage}" != "${mirror_homepage}" ]]; then
    _github_homepage_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_homepage}"
  fi
}

_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_topics_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=() \
    _target_topics=() \
    _repo
  _repo="${_target_repo}"
  _msg=(
    "Checking"
    "'${_target_namespace}/${_repo}'"
    "topics."
  )
  _msg_info \
    "${_msg[*]}"
  _topics=( $(
    _topics_get \
      "${_target_namespace}" \
      "${_repo}")
  )
  if [[ "${_topics[*]}" == "" ]]; then
    _msg=(
      "Found no topics on"
      "mirror '${_target_repo}-ur'."
    )
    _msg_info \
      "${_msg[*]}"
  fi
  for _topic in "${mirror_topics[@]}"; do
    if [[  " ${_topics[*]} " != *" ${_topic} "* ]]; then
      _msg=(
        "Missing '${_topic}'."
      )
      _msg_info \
        "${_msg[*]}"
      _github_topic_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_topic}"
    fi
  done
}

_gl_dl_token_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_domain="${3}" \
    _git_service="${4}" \
    _token_private \
    _token
  _token_private_get \
    "${_git_domain}" \
    "${_target_namespace}"
  _token="$(
    cat \
      "${_token_private}")"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "GL_DL_PRIVATE_TOKEN" \
    "${_token}" \
    "private"
}

_bur_gpg_key_get() {
  local \
    _target_namespace="${1}" \
    _git_service \
    _evm_gpg_opts=() \
    _msg=() \
    _bur_name
  if (( 1 < "${#}" )); then
    _git_service="${2}"
  fi
  _bur_id="${_git_service}.bur.${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _evm_gpg_opts+=(
      -N
        "${_bur_id}"
      -t
        "private"
    )
  fi
  _bur_gpg_key="$(
    evm-gpg \
      "${_evm_gpg_opts[@]}" \
      export || \
      true)"
  if [[ "${_bur_gpg_key}" == "" ]]; then
    if [[ "${quiet}" == "n" ]]; then
      _evm_gpg_opts+=(
        -v
      )
    fi
    evm-gpg \
      "${_evm_gpg_opts[@]}" \
      new \
      "${_bur_id}" \
      "'${_target_namespace}' bur '${_target_namespace}' builder signing key"
    _bur_gpg_key="$(
      evm-gpg \
        "${_evm_gpg_opts[@]}" \
        export || \
        true)"
  fi
}

_bur_gpg_key_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_service="${3}" \
    _bur_gpg_key \
    _key_encoded
  _bur_gpg_key_get \
    "${_target_namespace}" \
    "${_git_service}"
  _key_encoded="$(
    echo \
      "${_bur_gpg_key}" |
      base64 \
        -w0)"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "BUR_GPG_KEY" \
    "${_key_encoded}" \
    "private"
}

_github_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _gh_opts=() \
    _user_missing_error=() \
    _repo_url
  _repo_url="https://github.com/${_namespace}/${_repo}"
  _repo_new_failed=""
  _user_missing_error+=(
    "HTTP 404: Not Found"
    "(https://api.github.com/users/${_namespace})"
  )
  _gh_opts+=(
    --private
    "${_namespace}/${_repo}"
  )
  _create="$(
    gh \
      repo \
        create \
        "${_gh_opts[@]}" \
        2>&1 || \
    true)"
  if [[ "${_create}" == "${_user_missing_error[*]}" ]]; then
    _msg=(
      "Can't create repository '${_repo}' on"
      "non-existent '${_namespace}' Github.com"
      "namespace."
    )
    _msg_error \
      "${_msg[*]}" \
      0
    _repo_new_failed="true"
  elif [[ "${_create}" == "${_repo_url}" ]]; then
    _msg=(
      "Repository '${_repo}' successfully"
      "created on namespace '${_namespace}'"
      "on Github.com."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_create}" != "${_user_missing_error[*]}" && \
          "${_create}" != "${_repo_url}" ]]; then
    echo \
      "${_create}"
    _msg=(
      "Uknown error creating Github"
      "repository."
    )
    _msg_error \
      "${_msg[*]}" \
      0
  elif [[ "${_create}" == "" ]]; then
    _msg=(
      "Repository '${_repo}' successfully"
      "created on namespace '${_namespace}'"
      "on Github.com."
    )
    _msg_info \
      "${_msg[*]}"
  fi
}

_namespaces_get() {
  local \
    _user="${1}" \
    _git_service
  _git_service="gitlab"
  if (( 1 < "${#}" )); then
    _git_service="${2}"
  fi
  "_${_git_service}_namespaces_get" \
    "${_user}"
}

_gitlab_namespaces_get() {
  local \
    _user="${1}" \
    _api \
    _curl_opts=() \
    _token \
    _token_private \
    _url
  _api="https://gitlab.com/api/v4"
  _url="${_api}/namespaces"
  _token_private_get \
    "gitlab.com" \
    "${_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _namespaces="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}" || \
      true)"
  if [[ "${_namespaces}" == "" ]]; then
    _msg=(
      "Found no namespaces"
      "corresponding to token"
      "'${_token_private}' for user"
      "'${_user}' on Gitlab.com."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _error="$(
    echo \
      "${_namespaces}" |
      jq \
        --raw-output \
        ".error" \
        2>"/dev/null" || \
        true)"
  if [[ "${_error}" != "" ]]; then
    _msg=(
      "Error retrieving namespaces"
      "for user '${_user}':"
    )
    _msg_error \
      "${_msg[*]}" \
      0
    _msg=( "$(
      echo \
        "${_namespaces}" |
        jq \
          --raw-output \
          ".error_description")"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_namespace_id_get() {
  local \
    _namespace="${1}" \
    _api \
    _curl_opts=() \
    _namespaces \
    _token \
    _token_private \
    _url
  _namespaces_get \
    "${_namespace}" || \
    true
  _namespace_id="$(
    echo \
      "${_namespaces}" |
      jq \
        '.[] | select(.path=="'${_namespace}'") | .id')"
}

_gitlab_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _api \
    _curl_opts=() \
    _namespace_id \
    _token \
    _token_private \
    _url
  _namespace_id_get \
    "${_namespace}" || \
    true
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "POST"
    -XGET
    --header
      "${_token}"
    --header
      "Content-Type: application/json"
    --data
      '{ "name":
           "'${_repo}'",
           "path":
             "'${_repo}'",
           "namespace_id":
             "'${_namespace_id}'",
           "initialize_with_readme":
             "false" }'
  )
  _repo_new_out="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
}

_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _git_service
  _git_service="github"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_repo_new" \
    "${_namespace}" \
    "${_repo}"
}

_quota_get() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  if [[ "${_git_service}" != "github" ]]; then
    "_${_git_service}_quota_get" \
      "${_namespace_user}" \
      "${_namespace_target}"
  fi
}

_quota_check() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_check" \
    "${_namespace_user}" \
    "${_namespace_target}"
}

_quota_query() {
  local \
    _namespace_id="${1}" \
    _namespace_type \
    _gid
  _namespace_type="user"
  if (( 1 < "${#}" )); then
    _namespace_type="${2}"
  fi
  if [[ "${_namespace_type}" == "user" ]]; then
    _gid="gid://gitlab/Namespace/${_namespace_id}"
  elif [[ "${_namespace_type}" == "group" ]]; then
    _gid="gid://gitlab/Group/${_namespace_id}"
  fi
  _test=(
    "{"
      'ciMinutesUsage(namespaceId: \"'${_gid}'\", first: 1) {'
        "nodes {"
          "month"
          "monthIso8601"
          "minutes"
          "projects {"
            "nodes {"
              "minutes"
              "project {"
                "id" 
                "name"
              "}"
            "}"
          "}"
         "}"
      "}"
    "}"
  )
  IFS='' \
    read \
      -r \
      -d '' \
      _query << \
        ENDQUERYTEXT || true
{ "query": "query ${_test[*]}" }
ENDQUERYTEXT
}

_groups_get() {
  local \
    _user="${1}" \
    _api \
    _curl_opts=() \
    _token \
    _token_private \
    _url
  _api="https://gitlab.com/api/v4"
  _url="${_api}/groups"
  _token_private_get \
    "gitlab.com" \
    "${_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _groups="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}" || \
      true)"
  if [[ "${_groups}" == "" ]]; then
    _msg=(
      "Found no groups"
      "for user"
      "'${_user}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _error="$(
    echo \
      "${_groups}" |
      jq \
        ".error" \
        2>"/dev/null" || \
        true)"
  if [[ "${_error}" != "" ]]; then
    _msg=(
      "Error retrieving groups"
      "for user '${_user}':"
    )
    _msg_error \
      "${_msg[*]}" \
      0
    _msg=( "$(
      echo \
        "${_groups}" |
        jq \
          ".error_description")"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_group_namespace_check() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _groups \
    _group
  _namespace_id_get \
    "${_namespace_target}"
  _groups_get \
    "${_namespace_user}"
  _group="$(
    echo \
      "${_groups}" |
      jq \
        --raw-output \
        '.[] | select(.path == "'${_namespace_target}'") | .path' \
        || \
        true)"
  if [[ "${_group}" != "null" && \
        "${_group}" != "" ]]; then
    _msg=(
      "Namespace '${_namespace_target}'"
      "is a group."
    )
    _msg_info \
      "${_msg[*]}"
    _namespace_type="group"
  fi
}

_gitlab_quota_get() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _curl_opts=() \
    _graphql_opts=() \
    _api \
    _bearer \
    _graphql \
    _minutes \
    _namespace_id \
    _namespace_type \
    _url \
    _token_private \
    _token \
    _msg=()
  _namespace_type="user"
  _graphql="https://gitlab.com/api/graphql"
  _token_private_get \
    "gitlab.com" \
    "${_namespace_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _bearer="Authorization: Bearer $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _namespace_id_get \
    "${_namespace_target}"
  _group_namespace_check \
    "${_namespace_user}" \
    "${_namespace_target}"
  _quota_query \
    "${_namespace_id}"
  _graphql_opts+=(
    --request
      "POST"
    --url
      "${_graphql}"
    --silent
    -XGET
    --header
      "${_bearer}"
    --header
      "Content-Type: application/json"
    --data
      "${_query}"
  )
  _minutes="$(
    curl \
      "${_graphql_opts[@]}" |
      jq \
        ".data.ciMinutesUsage.nodes.[].minutes")"
  if [[ "${_minutes}" == "" ]]; then
    if [[ "${_namespace_type}" == "group" ]]; then
      _msg=(
        "User '${_namespace_user}'"
        "doesn't have access to usage data"
        "of '${_namespace_target}' group."
      )
    else
      _msg=(
        "Unknown error."
        )
    fi
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  echo \
    "${_minutes}"
}

_github_repo_exists() {
  local \
    _namespace="${1}" \
    _namespace_active \
    _repo="${2}" \
    _switch_error=() \
    _msg=()
  _msg=(
    "Checking existence of"
    "repository '${_repo}'"
    "on namespace '${_namespace}'"
    "on Github.com"
  )
  _msg_info \
    "${_msg[*]}"
  _switch_error=(
    "no accounts matched that criteria"
  )
  _namespace_active="$(
    _github_account_active_get)"
  _switch="$(
    gh \
      auth \
        switch \
        -u \
          "${_namespace}" || \
    gh \
      auth \
        switch \
        -u \
          "${_namespace_active}")"
  if [[ "${_switch}" == "${_switch_error[*]}" ]]; then
    _msg=(
      "No '${_namespace}' account"
      "configured for Github.com."
    )
    _msg_info \
      "${_msg[*]}"
    _exists="false"
  elif [[ "${_switch}" != "${_switch_error[*]}" ]]; then
    _exists="$(
      gh \
        repo \
          view \
            "${_namespace}/${_repo}" 2>"/dev/null" || \
      true)" 
  else
    echo \
      "${_switch}"
    _msg=(
      "Unknown error while"
      "switching account."
    )
    _exists=""
    _msg_error \
      "${_msg[*]}" \
      0
  fi
}

_gitlab_repo_exists() {
  local \
    _namespace="${1}" \
    _repo="${2}"
  _exists="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
}

_repo_exists() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _service \
    _checked
  _service="${_git_services[0]}"
  if (( 2 < "${#}" )); then
    _service="${3}"
  fi
  _check_local \
    "${_namespace}" \
    "${_repo}" \
    "${_service}" \
    "exists"
  if [[ "${_checked}" == "true" ]]; then
    _msg=(
      "Repository"
      "'${_namespace}/${_repo}'"
      "already exists on '${_service}'."
    )
    _msg_info \
      "${_msg[*]}"
    _exists="true"
  elif [[ "${_checked}" == "false" ]]; then
    _msg=(
      "Checking existence of"
      "'${_namespace}/${_repo}'"
      "on '${_service}'."
    )
    _msg_info \
      "${_msg[*]}"
    "_${_service}_repo_exists" \
      "${_namespace}" \
      "${_repo}"
    _checked_local \
      "${_namespace}" \
      "${_repo}" \
      "${_service}" \
      "exists"
  fi
}

_repo_check() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tmp_dir \
    _git_opts=() \
    _exists \
    _msg=()
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  _oldpwd="${PWD}"
  _tmp_dir="$(
    mktemp \
      -d)"
  cd \
    "${_tmp_dir}"
  _repo_exists \
    "${_namespace}" \
    "${_repo}" \
    "${_git_service}"
  if [[ "${_exists}" == "" ]]; then
    _msg=(
      "Creating repository"
      "'${_namespace}/${_repo}' on"
      "'${_git_service}'."
    )
    _msg_info \
      "${_msg[*]}"
    _repo_new \
      "${_namespace}" \
      "${_repo}" \
      "${_git_service}"
  elif [[ "${_exists}" == "false" ]]; then
    _msg=(
      "Skipping repository '${_namespace}'"
      "on service '${_git_service}'."
    )
  elif [[ "${_exists}" != "" && \
          "${_exists}" != "" ]]; then
    _msg=(
      "Repository '${_repo}'"
      "found on '${_namespace}' namespace"
      "on '${_git_service}'."
    )
    _msg_info \
      "${_msg[*]}"
  fi
  cd \
    "${_oldpwd}"
}

_exists_check() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tmp_dir \
    _git_opts=() \
    _exists \
    _msg=()
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_repo_exists" \
    "${_namespace}" \
    "${_repo}-ur" \
    "${_git_service}"
}

_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_services=()
  shift \
    2
  _git_services+=(
    "$@"
  )
  if [[ "${_git_services[*]}" == "" ]]; then
    _git_services+=(
      "github"
      "gitlab"
    )
  fi
  for _service in "${_git_services[@]}"; do 
    _exists_check \
      "${_target_namespace}" \
      "${_target_repo}" \
      "${_service}"
    "_${_service}_ci_check" \
      "${_target_namespace}" \
      "${_target_repo}"
  done
}

_github_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _secrets_missing=() \
    _bur_gpg_key \
    _repo \
    _git_service \
    _checked
  _git_service="github"
  _repo="${_target_repo}-ur"
  _check_local \
    "${_target_namespace}" \
    "${_target_repo}" \
    "github" \
    "ci"
  if [[ "${_checked}" == "true" ]]; then
    _msg=(
      "Github.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment"
      "already configured."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_checked}" == "false" ]]; then
    _msg=(
      "Checking Github.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration variables."
    )
    _msg_info \
      "${_msg[*]}"
    _secrets=( $(
      _github_secrets_get \
        "${_target_namespace}" \
        "${_repo}")
    )
    if [[ " ${_secrets[*]} " != *" GL_DL_PRIVATE_TOKEN "* ]]; then
      _msg=(
        "Missing secret github.com"
        "access token variable"
        "'GL_DL_PRIVATE_TOKEN',"
        "setting up."
      )
      _msg_info \
        "${_msg[*]}"
      _gl_dl_token_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}.com" \
        "${_git_service}"
    fi
    if [[ " ${_secrets[*]} " != *" BUR_GPG_KEY "* ]]; then
      _msg=(
        "Missing secret gitlab.com"
        "access token variable"
        "'BUR_GPG_KEY', setting up."
      )
      _msg_info \
        "${_msg[*]}"
      _bur_gpg_key_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}"
    fi
    _bur_gpg_key_set \
      "${_target_namespace}" \
      "${_repo}" \
      "${_git_service}"
    _checked_local \
      "${_target_namespace}" \
      "${_target_repo}" \
      "github" \
      "ci"
  fi
}

_check_local() {
  local \
    _namespace="${1}" \
    _target_repo="${2}" \
    _service="${3}" \
    _object_type="${4}" \
    _pkg_dir \
    _object_file
  _pkg_dir="${_cache_dir}/packages/${_target_repo}/${_namespace}"
  mkdir \
    -p \
    "${_pkg_dir}"
  _object_file="${_pkg_dir}/${_object_type}"
  _checked="$(
    cat \
      "${_object_file}" \
      2>"/dev/null" |
      grep \
        -c \
        "${_service}" || \
      true)"
  if [[ "${_checked}" == "1" ]]; then
    _checked="true"
  elif [[ "${_checked}" == "0" || \
          "${_checked}" == "" ]]; then
    _checked="false"
  fi
}

_checked_local() {
  local \
    _namespace="${1}" \
    _target_repo="${2}" \
    _service="${3}" \
    _object_type="${4}" \
    _object_dir \
    _object_file
  _object_dir="${_cache_dir}/packages/${_target_repo}/${_namespace}"
  _object_file="${_object_dir}/${_object_type}"
  mkdir \
    -p \
    "${_object_dir}"
  echo \
    "${_service}" >> \
    "${_object_file}"
}

_gitlab_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _env \
    _msg=() \
    _repo \
    _checked
  _check_local \
    "${_target_namespace}" \
    "${_target_repo}" \
    "gitlab" \
    "ci"
  _repo="${_target_repo}-ur"
  if [[ "${_checked}" == "true" ]]; then
    _msg=(
      "Gitlab.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment"
      "already configured."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_checked}" == "false" ]]; then
    _msg=(
      "Checking Gitlab.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment."
    )
    _msg_info \
      "${_msg[*]}"
    _gl_dl_token_set \
      "${_target_namespace}" \
      "${_repo}" \
      "gitlab.com" \
      "gitlab"
    _bur_gpg_key_set \
      "${_target_namespace}" \
      "${_repo}" \
      "gitlab"
    _checked_local \
      "${_target_namespace}" \
      "${_target_repo}" \
      "gitlab" \
      "ci"
  fi
}

_gitlab_env_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token \
    _variable \
    _message \
    _value
  _key=""
  if (( 2 < "${#}" )); then
    _key="${3}"
  fi
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  if [[ "${_key}" != "" ]]; then
    _url="${_url}/${_key}"
  fi
  _variable="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _message="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".message")"
  _value="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".value")"
  if [[ "${_value}" != "" &&
        "${_value}" != "null" ]]; then
    echo \
      "${_value}"
  elif [[ "${_message}" == "404 Variable Not Found" ]]; then
    return 1
  elif [[ "${_message}" == "404 Project Not Found" ]]; then
    _msg_error \
      "Check Project ID function."  \
      1
  else
    _msg_info \
      "${_variable}"
  fi
}

_github_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _gh_opts=() \
    _env_set_msg \
    _msg=() \
    _msg_no_repo=() \
    _msg_okay=()
  _msg_no_repo+=(
    "failed to fetch public key: HTTP 404: Not Found"
    "(https://api.github.com/repos/${_target_namespace}/${_target_repo}/actions/secrets/public-key)"
  )
  _msg_okay+=(
    "✓ Set Actions secret"
    "${_key} for"
    "${_target_namespace}/${_target_repo}"
  )
  _gh_opts+=(
    --repo
      "${_target_namespace}/${_target_repo}"
  )
  _msg=(
    "Running gh with options"
    "'${_gh_opts[*]}'."
  )
  _msg_info \
    "${_msg[*]}"
  _env_set_msg="$(
    gh \
      secret \
        "${_gh_opts[@]}" \
        set \
          "${_key}" \
          --body \
            "${_value}" \
          2>&1)"
  if [[ "${_env_set_msg}" == "${_msg_okay[*]}" ]]; then
    _msg=(
      "Variable '${_key}' correcly set on"
      "the 'Github' repository '${_target_repo}'"
      "on namespace '${_namespace}'."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_env_set_msg}" == "${_msg_no_repo[*]}" ]]; then
    _msg=(
      "Variable '${_key}' can't be set on"
      "the 'Github' repository '${_target_repo}'"
      "on namespace '${_namespace}' because"
      "the repo doesn't exist."
    )
    _msg_error \
      "${_msg[*]}" \
      0
  else
    if [[ "${_env_set_msg}" == "" ]]; then
      _msg=(
        "No output for set message"
      )
      _msg_info \
        "${_msg[*]}"
      gh \
        secret \
          "${_gh_opts[@]}" \
          set \
            "${_key}" \
            --body \
              "${_value}"
    else
      echo \
        "${_env_set_msg}"
      _msg=(
        "Error setting variable '${_key}'"
        "on Github.com repository '${_target_repo}'"
        "on namespace '${_namespace}'."
      )
      _msg_error \
        "${_msg[*]}" \
        1
    fi
  fi
}

_gitlab_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _type="${5}" \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token \
    _out
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
    --form
      key="${_key}"
    --form
      value="${_value}"
  )
  if [[ "${_type}" == "private" ]]; then
    _curl_opts+=(
      --form
        "masked_and_hidden=true"
    )
  fi
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  _variable="$(
    _gitlab_env_get \
      "${_target_namespace}" \
      "${_target_repo}" \
      "${_key}" || \
      true)"
  if [[ "${_variable}" != "" ]]; then
    _msg=(
      "Updating variable"
      "'${_key}'."
    )
    _msg_info \
      "${_msg[*]}"
    _curl_opts+=(
      --request
        "PUT"
    )
    _url="${_url}/${_key}"
  elif [[ "${_variable}" == "" ]]; then
    _msg=(
      "Writing variable"
      "'${_key}'."
    )
    _msg_info \
      "${_msg[*]}"
    _curl_opts+=(
      --request
        "POST"
    )
  fi
  _out="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _hidden="$(
    echo \
      "${_out}" |
      jq \
        --raw-output \
        '.hidden' || \
      true)"
  _masked="$(
    echo \
      "${_out}" |
      jq \
        --raw-output \
        '.masked' || \
      true)"
  if [[ "${_hidden}" == "true" && \
        "${_masked}" == "true" ]]; then
    _msg=(
      "Variable '${_key}' correctly"
      "written."
    )
    _msg_info \
     "${_msg[*]}" 
  fi
}

_project_id_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _curl_opts=() \
    _project \
    _project_id \
    _token_private \
    _token
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _project="$(
    curl \
      "${_curl_opts[@]}" \
      "https://gitlab.com/api/v4/projects/${_namespace}%2F${_repo}")"
  _project_id="$(
    echo \
      "${_project}" |
      jq \
      '.id')"
  if [[ "${_project_id}" == "null" ]]; then
    _project_id=""
  fi
  echo \
    "${_project_id}"
}

_artifacts_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _job_latest \
    _old_pwd \
    _token_private
  _token_private_get
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg_info \
    "Found job id '${_job_latest}'."
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_latest}/artifacts"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -o
      "${_cache_dir}/${_namespace}/artifacts.zip"
    -f
      "zip"
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  mkdir \
    -p \
    "${_cache_dir}/${_namespace}/artifacts"
  _old_pwd=${PWD}
  cd \
    "${_cache_dir}/artifacts"
  unzip \
    -qq \
    "${_cache_dir}/${_namespace}/artifacts.zip"
  rm \
    "${_cache_dir}/${_namespace}/artifacts.zip"
  for _artifact \
    in "./"*; do
    basename \
      "${_artifact}"
    mv \
      "${_artifact}" \
      "${_old_pwd}"
  done
  cd \
    "${_old_pwd}"
  rmdir \
    "${_cache_dir}/artifacts"
}

_artifacts_check() {
  # TODO
  true
}

_gitlab_pipeline_latest_get() {
  local \
    _project_id="${1}" \
    _pipelines=()
  _gitlab_pipelines_get \
    "${_project_id}" \
    "${_target_namespace}"
}

_gitlab_job_latest_get() {
  local \
    _project_id="${1}" \
    _jobs=()
  _gitlab_jobs_get \
    "${_project_id}"
  _job_latest="$(
    IFS=$'\n'
    echo \
      "${_jobs[*]}" |
      sort \
        -nr |
          head \
            -n \
              1)"
  # _job_latest="${_jobs[0]}"
}

_token_private_get() {
  local \
    _domain \
    _token_dir \
    _token_namespace \
    _msg=()
  _domain="gitlab.com"
  if (( 0 < "${#}" )); then
    _domain="${1}"
  fi
  _namespace="default"
  if (( 1 < "${#}" )); then
    _namespace="${2}"
  fi
  _token_dir="${HOME}/.config/${_domain}"
  _token_private="${_token_dir}/default.txt"
  _token_namespace="${_token_dir}/${_namespace}.txt"
  if [[ -e "${_token_namespace}" ]]; then
    _token_private="${_token_namespace}"
    _msg=(
      "Selecting namespace token."
    )
  fi
  if [[ ! -e "${_token_private}" ]]; then
    mkdir \
      -p \
      "${_token_dir}"
    chmod \
      700 \
      "${_token_dir}"
    _msg=(
      "Missing private token at"
      "'${_token_private}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_gitlab_pipelines_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_target_namespace}"
    -o
      "${_cache_dir}/pipelines.json" 
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/pipelines?per_page=20&sort=desc"
  _jobs+=( $(
    cat \
      "${_cache_dir}/pipelines.json" |
      jq \
        '.[]' |
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_github_releases_get() {
  local \
    _repo="${1}" \
    _namespace="${2}" \
    _releases=()
  _msg=(
    "Checking existence of"
    "repository '${_repo}'"
    "on namespace '${_namespace}'"
    "on Github.com"
  )
  _msg_info \
    "${_msg[*]}"
  _switch_error=(
    "no accounts matched that criteria"
  )
  _switch="$(
    gh \
      auth \
        switch \
        -u \
          "${_namespace}" \
        2>&1)"
  if [[ "${_switch}" == "${_switch_error[*]}" ]]; then
    _msg=(
      "No '${_namespace}' account"
      "configured for Github.com."
    )
    _msg_info \
      "${_msg[*]}"
    # _releases="false"
  elif [[ "${_switch}" != "${_switch_error[*]}" ]]; then
    gh \

    # _exists="$(
    #   gh \
    #     repo \
    #       view \
    #         "${_namespace}/${_repo}" 2>"/dev/null" || \
    #   true)" 
  else
    echo \
      "${_switch}"
    _msg=(
      "Unknown error while"
      "switching account."
    )
    _exists=""
    _msg_error \
      "${_msg[*]}" \
      0
  fi
}

_github_releases_get() {
  local \
    _repo="${1}" \
    _namespace="${2}"
  echo \
    "stub"
}


_gitlab_releases_get() {
  cat \
    "${_cache_dir}/releases.json" |
    jq \
      --raw-output \
      '.[].tag_name' |
      sort \
        -V
}

_gitlab_release_latest_get() {
  _tag="$(
    cat \
      "${_cache_dir}/releases.json" |
      jq \
        --raw-output \
        '.[].tag_name' |
        sort \
          -V |
        tail \
          -n \
            1)"
}

_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}"
  _gitlab_release_get \
    "${_namespace}" \
    "${_repo}"
}

_gitlab_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tag \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _urls=() \
    _job_latest \
    _output_file \
    _token_private
  shift \
    2
  _tag=""
  if (( 0 < "$#" )); then
    _tag="${1}"
  fi
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
  )
  _gitlab_releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  if [[ "${_tag}" == "" ]]; then
    _gitlab_release_latest_get
  fi
  _urls+=( $(
    cat \
      "${_cache_dir}/releases.json" |
      jq \
        --raw-output \
        '.[] | select(.tag_name == "'${_tag}'").assets.links.[].direct_asset_url')
  )
  for _url in "${_urls[@]}"; do
    _file="$(
      basename \
        "${_url}")"
    _output_file="$(pwd)/${_file}"
    gl-dl \
      "${_gl_dl_opts[@]}" \
      -o \
        "${_output_file}" \
      "${_url}"
  done
}

_releases_get() {
    _namespace="${1}" \
    _repo="${2}"
  _gitlab_releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  _gitlab_releases_get
  # cat \
  #   "${_cache_dir}/releases.json" |
  # jq
}

_gitlab_releases_retrieve() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/releases"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/releases.json"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
}

_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_log_get" \
    "${_namespace}" \
    "${_repo_name}"
}

_gitlab_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _msg=()
  _msg=(
    "Getting logs for"
    "project '${_repo}'"
    "on gitlab.com"
    "namespace '${_namespace}'."
  )
  _msg_info \
    "${_msg[*]}"
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  if [[ "${_project_id}" == "" ]]; then
    _msg=(
      "Retrieved null project"
      "id for project '${_repo}'"
      "on namespace '${_namespace}'"
      "on Gitlab.com."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg=(
    "Found job id '${_job_latest}'."
  )
  _msg_info \
    "${_msg[*]}"
  _gitlab_job_log_get \
    "${_namespace}" \
    "${_repo}" \
    "${_job_latest}"
}

_tag_recipe_get() {
  local \
    _msg=() \
    _pkgbuild
  _pkgbuild="${PWD}/PKGBUILD"
  _tag_recipe="$(
    echo \
      "$(recipe-get \
          "${_pkgbuild}" \
          "pkgver")-$(
      recipe-get \
        "${_pkgbuild}" \
        "pkgrel")" || \
    true)"
  if [[ "${_tag_recipe}" == "" ]]; then
    _msg=(
      "Error reading the git repo"
      "tag from the PKGBUILD"
      "at '${_pkgbuild}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_github_log_id_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _latest \
    _log_type \
    _gh_opts=() \
    _msg=() \
    _nargs \
    _tag_recipe \
    _run_id
  _nargs="${#}"
  _latest="true"
  # _log_type="release-build"
  _log_type="ci"
  if (( 2 < "${_nargs}" )); then
    _latest="${3}"
  fi
  if (( 3 < "${_nargs}")); then
    _log_type="${4}"
  fi
  if [[ "${_latest}" == "true" ]]; then
    _gh_opts+=(
      --repo
        "${_namespace}/${_repo}"
    )
  fi
  _tag_recipe_get
  _gh_opts+=(
    --branch
      "${_tag_recipe}"
    --json
      "databaseId"
    --jq
      ".[].databaseId"
  )
  _msg=(
    "Running gh with options"
    "${_gh_opts[@]}."
  )
  _msg_info \
    "${_msg[*]}"
  _log_id="$(
    gh \
      run \
        list \
        "${_gh_opts[@]}" |
      tail \
       -n \
         1 || \
    true)"
  if [[ "${_log_id}" == "" ]]; then
    _msg=(
      "Error retrieving log."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_github_log_type_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _log_id="${3}" \
    _gh_opts=() \
    _run_id \
    _log_types=() \
    _msg=() \
    _type \
    _workflow_name
  _log_types+=(
    "ci"
    "release-build"
  )
  _gh_opts+=(
    --repo
      "${_namespace}/${_repo}"
  )
  _gh_opts+=(
    --json
      "workflowName"
    --jq
      ".workflowName"
    "${_log_id}"
  )
  _msg=(
    "Running gh with options"
    "${_gh_opts[@]}."
  )
  _msg_info \
    "${_msg[*]}"
  _workflow_name="$(
    gh \
      run \
        view \
        "${_gh_opts[@]}")"
  _type_known="false"
  for _type in "${_log_types[@]}"; do
    if [[ "${_workflow_name}" == "${_type}" ]]; then
      _type_known="true"
      _log_type="${_workflow_name}"
      break
    fi
  done
  if [[ "${_type_known}" == "false" ]]; then
    _msg=(
      "Unkwnown type '${_workflow_name}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_github_build_task_name_get() {
  local \
    _platform \
    _arch \
    _nargs
  _nargs="${#}"
  _platform=""
  if (( 2 < "${_nargs}" )); then
    _platform="${3}"
  fi
  _arch=""
  if (( 3 < "${_nargs}" )); then
    _arch="${4}"
  fi
  if [[ "${_platform}" == "" ]]; then
    _platform="$(
      uname \
        -o)"
  fi
  if [[ "${_arch}" == "" ]]; then
    _arch="$(
      uname \
        -m)"
  fi
  if [[ "${_platform}" == "GNU/Linux" ]]; then
    _task_name=(
      "Life and DogeOS GNU"
      "Base package build"
      "(Arch CI). (ubuntu-24.04,"
      "gnu, arch, ${_arch}, amd64)"
    )
  elif [[ "${_platform}" == "Windows" ]]; then
    _task_name=(
      "Life and DogeOS"
      "Windows base packages (CI)."
      "(mingw64, x86_64, x86_64)"
    )
  elif [[ "${_platform}" == "Android" ]]; then
    _task_name=(
      "Life and DogeOS"
      "Android Base package"
      "build (Termux CI)."
      "(ubuntu-24.04, android,"
      "termux, x86_64)"
    )
  fi
}

_github_jobs_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _log_id \
    _job_type \
    _gh_opts=() \
    _msg=() \
    _run_id
  _job_type="ci"
  if (( 2 < "${#}" )); then
    _job_type="${3}"
  fi
  _gh_opts+=(
    --repo
      "${_namespace}/${_repo}"
  )
  _github_log_id_get \
    "${_namespace}" \
    "${_repo_name}"
  _github_log_type_get \
    "${_namespace}" \
    "${_repo_name}" \
    "${_log_id}"
  if [[ "${_log_type}" != "${_job_type}" ]]; then
    _msg=(
      "Task with ID '${_log_id}' corresponds"
      "corresponds to '${_job_type}' type."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _gh_opts+=(
    --json
      "jobs"
    --jq
      ".jobs.[].databaseId"
    "${_log_id}"
  )
  _msg=(
    "Running gh with options"
    "${_gh_opts[@]}."
  )
  _msg_info \
    "${_msg[*]}"
  _jobs=(
    $(gh \
        run \
          view \
          "${_gh_opts[@]}")
  )
  if (( "${#_jobs}" < 1 )); then
    _msg=(
      "No builds found for package"
      "'${_repo}' on namespace"
      "'${_namespace}' on github."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_github_job_latest_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _jobs=()
  _github_jobs_get \
    "${_namespace}" \
    "${_repo_name}"
  _job_latest="$(
    printf \
      "%s\n" \
      "${_jobs[@]}" |
      sort \
        -n |
        tail \
          -n \
            1)"
}

_github_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _watch \
    _platform \
    _arch \
    _gh_base_opts=() \
    _gh_opts=() \
    _job_latest \
    _jobs_selected=() \
    _jq_filter=() \
    _log_id \
    _nargs \
    _os \
    _tag_recipe \
    _run_id \
    _run_cmd=() \
    _repo_name \
    _task_name=() \
    _msg=()
  _nargs="${#}"
  _arch=""
  _platform=""
  _watch=""
  if (( 2 < "${_nargs}" )); then
    _platform="${3}"
  fi
  if (( 3 < "${_nargs}" )); then
    _arch="${4}"
  fi
  if (( 4 < "${_nargs}" )); then
    _watch="${5}"
  fi
  if [[ "${_platform}" == "" ]]; then
    _platform="$(
      uname \
        -o)"
  fi
  if [[ "${_arch}" == "" ]]; then
    _arch="$(
      uname \
        -m)"
  fi
  if [[ "${_watch}" == "" ]]; then
    _watch="n"
  fi
  _repo_name="${_repo}-ur"
  _gh_base_opts+=(
    --repo
      "${_namespace}/${_repo_name}"
  )
  _msg=(
    "Getting logs for"
    "project '${_repo_name}'"
    "on github.com"
    "namespace '${_namespace}'."
  )
  _msg_info \
    "${_msg[*]}"
  _github_job_latest_get \
    "${_namespace}" \
    "${_repo_name}"
  _jobs_selected=(
    "${_job_latest}"
  )
  for _job in "${_jobs_selected[@]}"; do
    _github_build_task_name_get
    _jq_filter=(
      ".jobs.[] |"
        "select("
          '.name == "'${_task_name[*]}'" ) |'
        ".databaseId"
    )
    _gh_opts=(
      "${_gh_base_opts[@]}"
      --json
        "jobs"
      --job
        "${_job}"
      --jq
        "${_jq_filter[*]}"
    )
    _msg=(
      "Running gh with options"
      "'${_gh_opts[*]}' and"
      "jq with filter '${_jq_filter[*]}'."
    )
    _msg_info \
      "${_msg[*]}"
    _log_id="$(
      gh \
        run \
          view \
          "${_gh_opts[@]}")"
    _gh_opts=(
      "${_gh_base_opts[@]}"
    )
    if [[ "${_watch}" == "n" ]]; then
      _run_cmd+=(
        view
      )
      _gh_opts+=(
        --log
        --job
          "${_log_id}"
      )
    elif [[ "${_watch}" == "y" ]]; then
      _github_log_id_get \
        "${_namespace}" \
        "${_repo_name}"
      _run_cmd+=(
        watch
          "${_log_id}"
      )
    fi
    gh \
      run \
        "${_run_cmd[@]}" \
        "${_gh_opts[@]}"
  done
}

_log_check() {
  true
}

_releases_check() {
  true
}

_release_check() {
  true
}

_gitlab_job_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _job_id="${3}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_id}/trace"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/trace.log"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  cat \
    "${_cache_dir}/trace.log"
}

_gitlab_jobs_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/jobs.json" 
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/jobs?per_page=20"
  _jobs+=( $(
    cat \
      "${_cache_dir}/jobs.json" |
      jq \
        '.[]' |
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_gur_get() {
  local \
    _target_namespace="${1}" \
    _target_key="${2}" \
    _target_value="${3}" \
    _args_extra=() \
    _target_field \
    _target_repo \
    _namespace_user \
    _namespace_target \
    _msg=()
  shift \
    3
  _args_extra+=(
    "$@"
  )
  if [[ " ${_target_key} " == "" ]]; then
    _msg=(
      "A field must be provided."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  if [[ "${_target_key}" == "repos" ]]; then
    _repos_get \
      "${_target_namespace}" \
      "${_git_services[0]}"
    echo \
      "${_repos[@]}"
  elif [[ "${_target_value}" == "" ]]; then
    _target_value="${_repo_name}"
    _msg=(
      "Using '${_repo_name}' as repo name."
      )
    _msg_info \
      "${_msg[*]}"
  fi
  if [[ "${_target_key}" == "quota" ]]; then
    _namespace_user="${_target_namespace}"
    _namespace_target="${_target_value}"
    for _service in "${_git_services[@]}"; do
      _quota_get \
        "${_target_namespace}" \
        "${_target_value}" \
        "${_service}"
    done
  fi
  if [[ "${_target_key}" == "log" ]]; then
    _namespace_user="${_target_namespace}"
    _namespace_target="${_target_value}"
    if (( 1 < "${#_git_services[@]}" )); then
      _msg=(
        "Showing log for more than"
        "a build service."
      )
      _msg_warning \
        "${_msg[*]}"
    fi
    for _service in "${_git_services[@]}"; do
      _log_get \
        "${_target_namespace}" \
        "${_target_value}" \
        "${_service}"
    done
  fi
  if [[ "${_target_key}" != "repos" && \
        "${_target_key}" != "quota" && \
        "${_target_key}" != "log" ]]; then
    if [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
      _target_field="${_target_key}"
      _target_repo="${_target_value}"
      "_${_target_field}_get" \
        "${_target_namespace}" \
        "${_target_repo}" \
        "${_args_extra[@]}"
    else
      _msg_error \
        "Unknown field '${_target_key}'." \
        1
    fi
  fi
}

_gur_namespaces_get() {
  local \
    _conf_dir \
    _namespace \
    _namespaces=() \
    _namespaces_db \
    _namespaces_disabled_db \
    _now \
    _update_delta \
    _update_last \
    _update_last_file \
    _update_threshold
  # The update threshold is set a month
  # by default
  _update_threshold="$((
    60 * 60 * 24 * 30))"
  _conf_dir="$(
    _get_conf_dir_path)"
  _update_last_file="${_conf_dir}/last-update.txt"
  _namespaces_db="${_conf_dir}/accounts.db"
  _namespaces_disabled_db="${HOME}/.config/${app_name}/accounts_disabled.db"
  if [[ ! -e "${_update_last_file}" ]]; then
    mkdir \
      -p \
      "${_conf_dir}"
    for _service in "${git_services[@]}"; do
      "_${_service}_namespaces_auto_detect"
    done
    date \
      "+%s" > \
      "${_update_last_file}"
  elif [[ -e "${_update_last_file}" ]]; then
    _update_last="$(
      cat \
        "${_update_last_file}")"
    _now="$(
      date \
        "+%s")"
    _update_delta="$((
      "${_now}" -
      "${_update_last}"))"
    if (( "${_update_threshold}" < "${_update_delta}" )); then
      for _service in "${git_services[@]}"; do
        "_${_service}_namespaces_auto_detect"
      done
      date \
        "+%s" > \
        "${_update_last_file}"
    fi
  fi
  if [[ ! -e "${_namespaces_db}" ]]; then
    mkdir \
      -p \
      "${_conf_dir}"
    printf \
      "%s\n" \
      "${target_namespaces[@]}" >> \
      "${_namespaces_db}"
  elif [[ -e "${_namespaces_db}" ]]; then
    _namespaces=( $(
      cat \
        "${_namespaces_db}")
    )
    for _namespace in "${target_namespaces[@]}"; do
      if [[ " ${_namespaces[*]} " != *" ${_namespace} "* ]]; then
        printf \
          "%s\n" \
          "${_namespace}" >> \
          "${_namespaces_db}"
      fi
    done
  fi
  cat \
    "${_namespaces_db}"
}

_gitlab_namespace_enabled_get() {
  local \
    _namespace="${1}" \
    _namespaces_array=() \
    _token_private \
    _token
  _gitlab_namespaces_array_get \
    "${_namespace}"
  if [[ " ${_namespaces_array[*]} " == *" ${_namespace} "* ]]; then
    _namespace_enabled="true"
  elif [[ " ${_namespaces_array[*]} " != *" ${_namespace} "* ]]; then
    _namespace_enabled="false"
  fi
}

_repo_sync() {
  local \
    _git_service="${1}" \
    _namespace="${2}" \
    _repo="${3}" \
    _repo_name="${4}" \
    _protocol \
    _namespace_enabled \
    _push \
    _remote \
    _remote_exists \
    _tags_push \
    _url \
    _msg=()
  _protocol="ssh"
  if (( 4 < "${#}" )); then
    _protocol="${5}"
  fi
  _repo_new_failed=""
  if [[ "${_git_service}" == "gitlab" ]]; then
    _gitlab_namespace_enabled_get \
      "${_namespace}"
  else
    _namespace_enabled="true"
  fi
  if [[ "${_namespace_enabled}" == "false" ]]; then
    _msg=(
      "Service '${_git_service}'"
      "not configured for namespace"
      "'${_namespace}'."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_namespace_enabled}" == "true" ]]; then
    _remote="${_namespace}-${_git_service}"
    _remote_exists="$(
      git \
        remote |
        grep \
         "${_remote}" || \
      true)"
    if [[ "${_remote_exists}" == "" ]]; then
      # Currently expects a working SSH configuration
      # for hostname '<namespace>-<git-service>'.
      if [[ "${_protocol}" == "ssh" ]]; then
        _url="${_remote}:${_namespace}/${_repo}"
      fi
      git \
        remote \
          add \
          "${_remote}" \
          "${_url}"
    fi
    _repo_check \
      "${_namespace}" \
      "${_repo}" \
      "${_git_service}"
    if [[ "${_repo_new_failed}" != "true" ]]; then
      _msg=(
        "Pushing to '${_remote}'."
      )
      _push="$(
        git \
          push \
            "${_remote}" \
          2>&1 || \
          true)"
      if [[ "${_push}" ==  "Everything up-to-date" ]]; then
        _msg=(
          "Remote '${_remote}' already updated."
        )
      else
        _msg=(
          "Push:"
          "'${_push}'"
        )
      fi
      _msg_info \
        "${_msg[*]}"
      if [[ "${_repo_type}" == "ur" ]]; then
        _ci_check \
          "${_namespace}" \
          "${_repo_name}" \
          "${_git_service}"
      fi
      _tags_push="$(
        git \
          push \
            "${_remote}" \
            --tags \
          2>&1 || \
          true)"
      if [[ "${_tags_push}" == "Everything up-to-date" ]]; then
        _msg=(
          "Tags for remote '${_remote}' already updated."
        )
      else
        _msg=(
          "Push tags:"
            "${_tags_push}"
        )
      fi
      _msg_info \
        "${_msg[*]}"
    fi
  fi || \
  true
}

_gur_sync() {
  local \
    _git_service="${1}" \
    _target_namespace="${2}" \
    _repo_name="${3}" \
    _target_value="${4}" \
    _cache_dir="${5}" \
    _repo_type="${6}" \
    _namespace \
    _namespaces=() \
    _remote \
    _repo_new_failed \
    _service \
    _msg=()
  _namespaces=( $(
    _gur_namespaces_get)
  )
  _repo="${_repo_name}"
  if [[ "${_repo_type}" == "ur" ]]; then
    _repo="${_repo_name}-ur"
  fi
  if [[ "${_repo}" == "" ]]; then
    _repo="$(
      basename \
        "${PWD}")"
  fi
  for _namespace in "${target_namespaces[@]}"; do
    for _service in "${_git_services[@]}"; do
      _repo_sync \
        "${_service}" \
        "${_namespace}" \
        "${_repo}" \
        "${_repo_name}" \
        "ssh"
    done
  done
}

_gur_build() {
  local \
    _git_service="${1}" \
    _target_namespace="${2}" \
    _repo_name="${3}" \
    _target_value="${4}" \
    _cache_dir="${5}" \
    _pkgbuild \
    _tag_recipe \
    _tag \
    _committed \
    _tag_exists \
    _target_repo \
    _remote \
    _msg=()
  _target_repo="${_target_key}"
  _ci_check \
    "${_target_namespace}" \
    "${_target_repo}" \
    "${_git_service}"
  _remote="${_target_namespace}-${_git_service}"
  _pkgbuild="${PWD}/PKGBUILD"
  # TODO:
  # check if repository ci
  # has already been configured
  # check if unstaged changes
  # if not commit
  # check if commit is tagged
  _tag_recipe_get
  _tag="${_tag_recipe}"
  _committed="$(
    git \
      commit \
      -a \
      -S \
      -m \
        "Gur generated commit." || \
    echo \
      "false")"
  if [[ "${_committed}" == "false" ]]; then
    _msg=(
      "No changes have been commit."
    )
    _msg_info \
      "${_msg[*]}"
  else
    echo \
      "${_committed}"
  fi
  _tag_exists="$(
    git \
      tag |
      grep \
        "\b${_tag}\b" || \
    true)"
  if [[ "${_tag_exists}" != "" ]]; then
    _msg=(
      "Tag '${_tag}' exists already locally,"
      "increase the 'pkgrel' variable"
      "in the PKGBUILD."
    )
    _msg_warning \
      "${_msg[*]}"
  elif [[ "${_tag_exists}" == "" ]]; then
    _msg=(
      "Creating tag '${_tag}'."
    )
    _msg_info \
      "${_msg[*]}"
    git \
      tag \
        -a \
        "${_tag}" \
        -m \
          "Gur generated release."
  fi
  git \
    push \
      "${_remote}"
  git \
    push \
      "${_remote}" \
      --tags
  # TODO:
  # implement build status command
  # which can just ask gitlab
  # if the repository has built
  # the corresponding binary release
}

_gur_accounts() {
  echo
}

_gur_check() {
  local \
    _git_service="${1}" \
    _target_namespace="${2}" \
    _target_key="${3}" \
    _target_value="${4}" \
    _cache_dir="${5}" \
    _checked \
    _field \
    _repo \
    _msg=()
  if [[ "${_target_value}" != "" ]]; then
    _repo="${_target_value}"
    _repos+=(
      "${_repo}"
    )
  elif [[ "${_target_value}" == "" ]]; then
    _msg=(
      "No repository selected, global check"
      "triggered."
    )
    _msg_info \
      "${_msg[*]}"
    if [[ ! -e "${_cache_dir}/mirrors.db" ]]; then
      _repos_get \
        "${_target_namespace}"
    elif [[ -e "${_cache_dir}/mirrors.db" ]]; then
      _msg=(
        "Using local mirrors list"
        "because Github has a miserable"
        "API limit."
      )
      _msg_info \
        "${_msg[*]}"
      _repos+=( $(
        cat \
          "${_cache_dir}/mirrors.db")
      )
    fi
  fi
  if [[ "${_target_key}" == "" ]]; then
    _msg=(
      "No field selected, checking all."
    )
    _msg_info \
      "${_msg[*]}"
    for _repo in "${_repos[@]}"; do
      _checked="$(
        ( cat \
            "${_cache_dir}/checked.db" |
            grep \
              "${_repo}" ) || \
          true)"
      if [[ "${_checked}" == "" ]]; then
        _msg=(
          "Mirror for package"
          "'${_repo}'"
          "unchecked, checking now."
        )
        _msg_info \
          "${_msg[*]}"
        for _field in "${mirror_fields[@]}"; do
          "_${_field}_check" \
            "${_target_namespace}" \
            "${_repo}" \
            "${_git_service}"
        done
        echo \
          "${_repo}" >> \
          "${_cache_dir}/checked.db"
      elif [[ "${_checked}" != "" ]]; then
        _msg=(
          "Mirror for package"
          "'${_repo}'"
          "already checked, skipping."
        )
        _msg_info \
          "${_msg[*]}"
      fi
    done
  elif [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
    _field="${_target_key}"
    for _repo in "${_repos[@]}"; do
      "_${_field}_check" \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}"
    done
  else
    _msg=(
      "Unknown field '${_target_key}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_gur() {
  local \
    _git_services_amount="${1}" \
    _target_namespaces_amount="${2}" \
    _cache_dir="${3}" \
    _repo_type="${4}" \
    _repo_name="${5}" \
    _target_command="${6}" \
    _target_key="${7}" \
    _target_value="${8}" \
    _git_services=() \
    _target_namespaces=() \
    _repos=() \
    _command_args=() \
    _msg=() \
    _service
  shift \
    8
  for _service \
    in $(seq \
           "${_git_services_amount}"); do
    _git_services+=(
      "${1}"
    ) 
    shift
  done
  for _namespace \
    in $(seq \
           "${_target_namespaces_amount}"); do
    _target_namespaces+=(
      "${1}"
    ) 
    shift
  done
  if (( 0 < "${_target_namespaces_amount}" )); then
    _target_namespace="${_target_namespaces[0]}"
  fi
  _command_args+=(
    "$@"
  )
  if [[ "${_target_command}" == "get" ]]; then
    _gur_get \
      "${_target_namespace}" \
      "${_target_key}" \
      "${_target_value}" \
      "${_command_args[@]}"
  elif [[ "${_target_command}" == "check" ]]; then
    for _service in "${_git_services[@]}"; do
      _gur_check \
        "${_service}" \
        "${_target_namespace}" \
        "${_target_key}" \
        "${_target_value}" \
        "${_cache_dir}"
      done
  elif [[ "${_target_command}" == "build" ]]; then
    for _service in "${_git_services[@]}"; do
      _gur_build \
        "${_service}" \
        "${_target_namespace}" \
        "${_repo_name}" \
        "${_target_value}" \
        "${_cache_dir}"
    done
  elif [[ "${_target_command}" == "sync" ]]; then
    # TODO:
    _gur_sync \
      "${_service}" \
      "${_target_namespace}" \
      "${_repo_name}" \
      "${_target_value}" \
      "${_cache_dir}" \
      "${_repo_type}"
  else
    _msg=(
      "Unknown command '${_target_command}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_cache_dir_auto_detect() {
  local \
    _cache_dir \
    _cache_dir_default
  _cache_dir="${HOME}/.cache/${app_name}"
  # for _namespace in "${target_namespaces[@]}"; do
  #   _cache_dir_default="${HOME}/.cache/${app_name}"
  #   if [[ ! -e "${_cache_dir}" ]]; then
  #     mkdir \
  #       -p \
  #       "${_cache_dir_default}"
  #     chmod \
  #       700 \
  #       "${_cache_dir_default}"
  #   fi
  # done
  _set_override \
    "cache" \
    "dir" \
    "${_cache_dir}"
}

_github_auto_detect() {
  local \
    _user \
    _hosts
  _hosts="${HOME}/.config/gh/hosts.yml"
  if [[ -e "${HOME}/.config/gh/hosts.yml" ]]; then
    _user="$(
      cat \
        "${_hosts}" |
        grep \
          "user: " |
          awk \
            '{print $2}')"
    if [[ "${_user}" != "" ]]; then
      git_services+=(
        "github"
      )
    fi
  fi
}

_gitlab_auto_detect() {
  local \
    _token_dir
  _token_dir="${HOME}/.config/gitlab.com"
  _tokens_amount="$(
    _gitlab_token_private_dir_scan |
      wc \
       -l)"
  if (( 0 < "${_tokens_amount}" )); then
     git_services+=(
      "gitlab"
    )
  fi
}

_git_services_auto_detect() {
  local \
    _service \
    _services=()
  _services+=(
    "github"
    "gitlab"
  )
  if [[ "${git_services[*]}" == "" ]]; then
    for _service in "${_services[@]}"; do
      "_${_service}_auto_detect"
    done
  fi
  git_services_amount="${#git_services[@]}"
}

_github_accounts_get() {
  local \
    _namespaces
  _namespaces="$(
    gh \
      auth \
        status \
        --json \
          "hosts" |
      jq \
      --raw-output \
        '.hosts."github.com".[].login' ||
    true)"
  if [[ "${_namespaces}" == "null" ]]; then
    _namespaces=""
  fi
  echo \
    "${_namespaces}"
}

_github_account_active_get() {
  local \
    _namespace
  _namespace="$(
    gh \
      auth \
      status \
      --json \
        "hosts" |
      jq \
        --raw-output \
        '.hosts."github.com".[] | select(.active == true).login' || \
    true)"
  if [[ "${_namespace}" == "null" ]]; then
    _namespace=""
  fi
  echo \
    "${_namespace}"
}

_github_namespaces_auto_detect() {
  local \
    _namespace_active \
    _namespaces=()
  _namespace_active="$(
    _github_account_active_get)"
  if [[ "${_namespace_active}" != "" &&
        " ${target_namespaces[*]} " != *" ${_namespace_active} "* ]]; then
    target_namespaces+=(
      "${_namespace_active}"
    )
  fi
  _namespaces+=(
    $(_github_accounts_get)
  )
  for _namespace in "${_namespaces[@]}"; do
    if [[ "${_namespace}" != "${_namespace_active}" ]]; then
      if [[ " ${target_namespaces[*]} " != *" ${_namespace} "* ]]; then
        target_namespaces+=(
          "${_namespace}"
        )
      fi
    fi
  done
}

_gitlab_token_expired_check() {
  local \
    _namespace="${1}" \
    _error="${2}" \
    _error_msg=()
  _error_msg=(
    "Token is expired."
    "You can either do"
    "re-authorization"
    "or token refresh."
  )
  if [[ "${_error}" == "${_error_msg[*]}" ]]; then
    _msg=(
      "Token for reported '${_namespace}'"
      "namespace has expired, re-authorize it"
      "or refresh it."
    )
    _msg_warning \
      "${_msg[*]}" 
  else
    _msg_error \
      "${_error}" \
      1
  fi
}

_gitlab_token_owner_get() {
  local \
    _namespace="${1}" \
    _api \
    _curl_opts=() \
    _json \
    _lib \
    _msg=() \
    _token \
    _token_info \
    _token_private \
    _url
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/personal_access_tokens/self"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _token_info="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _user_id="$(
    echo \
      "${_token_info}" |
    jq \
      --raw-output \
      '.user_id')"
  _error="$(
    echo \
      "${_token_info}" |
    jq \
      --raw-output \
      '.error_description' ||
      true)"
  if [[ "${_error}" != "null" &&
        "${_error}" != "" ]]; then
    _gitlab_token_expired_check \
      "${_namespace}" \
      "${_error}"
  fi
  if [[ "${_user_id}" == "null" ]]; then
    _user_id=""
  fi
  _gitlab_username_get \
    "${_user_id}"
}

_gitlab_username_get() {
  local \
    _namespace="${1}" \
    _user_id="${1}" \
    _account_info \
    _api \
    _curl_opts=() \
    _json \
    _msg=() \
    _token \
    _token_private \
    _url \
    _username
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/users/${_user_id}"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _account_info="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _username="$(
    echo \
      "${_account_info}" |
      jq \
        --raw-output \
        ".username" \
      2>"/dev/null" || \
    true)"
  if [[ "${_username}" == "null" ]]; then
    _username=""
  fi
  echo \
    "${_username}"
}

_gitlab_namespaces_array_get() {
  local \
    _namespace="${1}" \
    _namespaces \
    _token_private \
    _username
  _gitlab_namespaces_get \
    "${_namespace}"
  _namespaces_array=( $(
    echo \
      "${_namespaces}" |
      jq \
        --raw-output \
        '.[].path' || \
      true)
  )
}

_gitlab_token_private_dir_scan() {
  local \
    _pat_dir
  _pat_dir="${HOME}/.config/gitlab.com"
  find \
    "${_pat_dir}" \
    -maxdepth \
      1 \
    \( -type \
      "f" \
    -o \
    -type \
      "l" \
    \)
}

_gitlab_namespaces_auto_detect() {
  local \
    _namespace \
    _namespaces_array=() \
    _pat_dir \
    _target_namespace \
    _token
  for _token \
    in $(_gitlab_token_private_dir_scan); do
    _namespace="$(
      basename \
        "${_token%.txt}")"
    _username="$(
      _gitlab_token_owner_get \
        "${_namespace}")"
    if [[ "${_username}" != "" ]]; then
      _gitlab_namespaces_array_get \
        "${_namespace}"
      if [[ " ${_namespaces_array[*]} " == *" ${_namespace} "*  ]]; then
        if [[ " ${target_namespaces[*]} " != *" ${_namespace} "* ]]; then
          target_namespaces+=(
            "${_namespace}"
          )
        fi
      fi
    fi
  done
}

_target_namespaces_auto_detect() {
  local \
    _msg=()
  if [[ "0" == "${#target_namespaces[@]}" ]]; then
    target_namespaces+=( $(
      _gur_namespaces_get)
    )
  fi
}

_repo_type_get() {
  local \
    _dir="${1}"
  if [[ -e "${_dir}/PKGBUILD" ]]; then
    _repo_type="ur"
  elif [[ -e "${_dir}/.git" ]]; then
    _repo_type="source"
  fi
}

_repo_info_build_cmd_auto_detect() {
  if [[ "${target_command}" == "build" ]]; then
    if [[ "${target_key}" == "${_repo_name}" || \
          "${target_key}" == "" ]]; then
      target_key="${_repo_name}"
      _repo_type_get \
        "${PWD}"
    fi
  fi
}

_repo_info_log_cmd_auto_detect() {
  if [[ "${target_command}" == "get" && \
        "${target_key}" == "log" ]]; then
    if [[ "${target_value}" == "${_repo_name}" || \
          "${target_value}" == "" ]]; then
      target_value="${_repo_name}"
      _repo_type_get \
        "${PWD}"
      if [[ "${_repo_type}" == "source" ]]; then
        _msg=(
          "Logs can be retrieved only for"
          "repositories of type 'ur' (universal"
          "recipe)."
        )
        _msg_error \
          "${_msg[*]}" \
          0
        _display_help="true"
      fi
    fi
  fi
}

_repo_info_sync_cmd_auto_detect() {
  if [[ "${target_command}" == "sync" ]]; then
    if [[ "${target_key}" == "${_repo_name}" || \
          "${target_key}" == "" ]]; then
      target_key="${_repo_name}"
      _repo_type_get \
        "${PWD}"
    fi
  fi
}

_repo_info_auto_detect() {
  local \
    _repo_type \
    _repo_name
  _repo_type=""
  _repo_name="$(
    basename \
      "${PWD}")"
  _repo_info_build_cmd_auto_detect
  _repo_info_log_cmd_auto_detect
  _repo_info_sync_cmd_auto_detect
  _set_override \
    "repo" \
    "type" \
    "${_repo_type}"
  _set_override \
    "repo" \
    "name" \
    "${_repo_name}"
}

_set_overrides() {
  local \
    _display_help
  _display_help="false"
  git_services_amount="${#git_services[@]}"
  target_namespaces_amount="${#target_namespaces[@]}"
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  _set_override \
    "run" \
    "date" \
    "$(_get_date_human)"
  _git_services_auto_detect
  _target_namespaces_auto_detect
  _set_override \
    "wallet" \
    "name" \
    "${target_namespaces[0]}"
  _cache_dir_auto_detect
  target_namespaces_amount="${#target_namespaces[@]}"
  _repo_info_auto_detect
  if [[ "${_display_help}" == "true" ]]; then
    _usage \
      1
  fi
}


# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _exit="${1}" \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true
Ur Github/Gitlab HTTP mirrors management tool

Usage:
  ${app_name}
    [options]
    <command>
      <key>
        <args>

  commands:
    build                   Creates a binary package release for
      <pkg>                 an Ur application.
    get                     Reads the value for the
      <key>                 selected key.
        (<args>)
    check                   Checks whether the selected
      <key>                 key (or all if none) has been
        (<args>)            correctly set for package mirror.
    sync                    To be used in a program source,
      <pkg>                 not in an universal recipe directory
                            in order to push changes to all
                            connected namespaces.

  keys:
    repos                   List all Ur repos in the
                            target namespace.
    description             Description of mirror repository.
    homepage                Homepage of a mirror repository.
    topics                  Topics of a mirror repository.
    project_id              Project ID for a Gitlab repository.
    artifacts               Latest artifact for an Ur Gitlab mirror.
    log                     Latest log for an Ur Gitlab mirror.
    releases                Get releases for an Ur Gitlab mirror.
    release                 Downloads a binary release built
                            on Ur Gitlab mirror.

  common args:
    package_name            An Ur package name (mirrors
                            have same name with just the
                            extra '-ur' suffix).

  release args:
    tag                     A specific release tag to download.
                            If not provided gets the latest.

  options:
     -m <git-service>       Git service, can be 'github'
                            or 'gitlab'.
                            Default: ${git_services[*]}
     -N <namespace>         Target namespace for the Ur
                            repositories.
                            Default: ${target_namespaces[*]}
     -t <repo-type>         Build and sync option.
                            It can be 'ur' (universal recipe)
                            or 'source' (the Git source repository
                            for an universal recipe).
                            Default: ${repo_type}
     -W <cache-dir>         Location where to temporary store
                            the downloaded resource chunks.
                            Default: ${cache_dir}

     -h                     This message.
     -c                     Enable color output
     -v                     Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${_exit}"
}

_display_flags() {
  local \
    _flags=(
      "${1}"
    ) \
    _flag
  for _flag \
    in "${_flags[@]}"; do
  _msg_info \
    "                             ${_flag}"
  done
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "                       Run date:   ${run_date}"
  _msg_info "                   Project name:   ${repo_name}"
  _msg_info "                   Git services:   ${git_services[*]}"
  _msg_info "              Target namespaces:   ${target_namespaces[*]}"
  _msg_info "                Repository type:   ${repo_type}"
  _msg_info "                Cache directory:   ${cache_dir}"
  _msg_info "                 Target command:   ${target_command}"
  _msg_info "                     Target key:   ${target_key}"
  _msg_info "                   Target value:   ${target_value}"
  _msg_info "                Extra arguments:   ${command_args[*]}"
}
_globals
_global_variables
_requirements
_config_user_init \
  "${app_name}"
# shellcheck disable=SC2034
while \
  getopts \
    'm:N:t:W:cvh?' \
    arg; do
  case \
    "${arg}" in
    m)
      git_services+=(
        "${OPTARG}"
      ) ;;
    N)
      target_namespaces+=(
        "${OPTARG}"
      ) ;;
    t)
      override_repo_type="${OPTARG}" ;;
    W)
      override_cache_dir="${OPTARG}" ;;
    c)
      override_color="y" ;;
    v)
      override_quiet="n" ;;
    h|?)
      _set_overrides
      _usage \
        0 ;;
    *)
    _msg=(
      "Invalid argument '${arg}'.")
    _msg_error \
      "${_msg[*]}" \
      0
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
if (( $# < 1 )); then
  _msg=(
    "No command given."
  )
  _msg_error \
    "${_msg[*]}"
    0
  _set_overrides
  _usage \
    1
fi
target_command="${1}"
_shift="1"
if (( 1 < $# )); then
  target_key="${2}"
  _shift="2"
fi
if (( 2 < $# )); then
  target_value="${3}"
  _shift="3"
fi
shift \
  "${_shift}"
command_args=(
  "$@"
)
_set_overrides
_show_config
app_opts=(
  "${git_services_amount}"
  "${target_namespaces_amount}"
  "${cache_dir}"
  "${repo_type}"
  "${repo_name}"
  "${target_command}"
  "${target_key}"
  "${target_value}"
  "${git_services[@]}"
  "${target_namespaces[@]}"
  "${command_args[@]}"
)
_gur \
  "${app_opts[@]}"

# vim:set sw=2 sts=-1 et:
