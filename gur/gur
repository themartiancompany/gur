#!/usr/bin/env bash

# SPDX-License-Identifier: AGPL-3.0-or-later

#    ----------------------------------------------------------------------
#    Copyright Â© 2024, 2025  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

_bin="$( \
  dirname \
    "$( \
      command \
        -v \
	  "env")")"
_lib="$( \
  realpath \
    "${_bin}/../lib")"
_crash_bash="${_lib}/libcrash-bash/crash-bash"
_sourced \
  "${_crash_bash}" 2>/dev/null || \
  source \
    "${_crash_bash}"

# shellcheck disable=SC2034
_global_variables() {
  run_date=""
  wallet_name=""
  target_namespace=""
  target_command=""
  target_key=""
  target_value=""
  cache_dir=""
  http="https://github.com"
  mirror_description=(
    "Ur uncensorable DogeOS"
    "and Life user repository"
    "and app store package HTTP mirror."
  )
  mirror_homepage="${http}/themartiancompany/ur"
  mirror_topics=(
    "ur"
    "ur-app-store"
    "universal-recipe"
    "user-repo"
    "dogeos-package"
    "life-package"
  )
  mirror_fields=(
    "exists"
    "description"
    "homepage"
    "topics"
    "project_id"
    "secrets"
    "artifacts"
    "ci"
    "env"
    "log"
    "releases"
    "release"
  )
  color=""
  quiet=""
}

_requirements() {
  _check_cmd \
    "cat" \
    "coreutils"
  _check_cmd \
    "curl"
  _check_cmd \
    'gh'
  _check_cmd \
    'gl-dl'
  _check_cmd \
    'python'
  _check_cmd \
    'jq'
  _check_cmd \
    "sort" \
    "coreutils"
  _check_cmd \
    "tail" \
    "coreutils"
  _check_cmd \
    "unzip"
}

_get_conf_dir_path() {
  local \
    _dir
  _dir="${HOME}/.config/gur"
  echo \
    "${_dir}"
}

_repos_get() {
  local \
    _namespace="${1}"
  _github_repos_get
}

_github_repos_get() {
  local \
    _namespace="${1}" \
    _repos_urls=() \
    _url \
    _repo \
    _repos_get_bin \
    _repos_get_opts=() \
    _lib \
    _msg=() \
    _token_private
  _lib="$( \
    _get_lib)"
  _repos_get_bin="${_lib}/gur/repos-get"
  _token_private_get \
    "github.com" \
    "${_namespace}"
  _repos_get_opts+=(
    --key
      "${_token_private}"
  )
  _msg=(
    "Retrieving list of"
    "Ur mirrors for"
    "'${_namespace}' namespace"
    "from Github."
  )
  _msg_info \
    "${_msg[*]}"
  _repos_urls=( $( \
    "${_repos_get_bin}" \
      "${_repos_get_opts[@]}" \
      "${_namespace}")
  )
  for _url in "${_repos_urls[@]}"; do
    _repo="$( \
      basename \
        "${_url}")"
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos+=(
        "${_repo%-ur}"
      )
    fi
  done
  _msg=(
    "Found '${#_repos[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "Saving list locally"
    "because Github API limit"
    "is ridiculous for a company"
    "which gives people free computers"
    "to build stuff."
  )
  _msg_info \
    "${_msg[*]}"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_cache_dir}/mirrors.db"
}

_github_description_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description
  _description="$( \
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "description" \
      --jq \
        ".description")"
  echo \
    "${_description}"
}

_github_homepage_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _homepage="$( \
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "homepageUrl" \
      --jq \
        ".homepageUrl")"
  echo \
    "${_homepage}"
}

_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}"
  _github_secrets_get \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _gh_opts=() \
    _repo_url
  _repo_url="${http}/${_target_namespace}/${_target_repo}"
  _gh_opts+=(
    --repo
      "${_repo_url}"
  )
  _secrets=( $(
    gh \
      "${_gh_opts[@]}" \
      secret \
        list | \
        awk \
          '{print $1}')
  )
  echo \
    "${_secrets[@]}"
}

_topics_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=()
  _topics=( $( \
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "repositoryTopics" \
      --jq \
        ".repositoryTopics.[].name" 2>/dev/null)
  )
  echo \
    "${_topics[@]}"
}

_github_description_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -d \
      "${_description}"
}

_github_homepage_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -h \
      "${_homepage}"
}

_github_topic_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topic="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    --add-topic \
      "${_topic}"
}

_project_id_check() {
  true
}

_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_description_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description \
    _msg=()
  _msg=(
    "Checking Github's"
    "'${_target_namespace}/${_target_repo}-ur'"
    "description."
  )
  _msg_info \
    "${_msg[*]}"
  _description="$( \
    _github_description_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_description}" != "${mirror_description[*]}" ]]; then
    _github_description_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_description[*]}"
  fi
}

_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_homepage_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _msg=(
    "Checking"
    "'${_target_namespace}/${_target_repo}-ur'"
    "homepage."
  )
  _msg_info \
    "${_msg[*]}"
  _homepage="$( \
    _homepage_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_homepage}" != "${mirror_homepage}" ]]; then
    _github_homepage_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_homepage}"
  fi
}

_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_topics_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=() \
    _target_topics=() \
    _repo
  _repo="${_target_repo}"
  _msg=(
    "Checking"
    "'${_target_namespace}/${_repo}'"
    "topics."
  )
  _msg_info \
    "${_msg[*]}"
  _topics=( $( \
    _topics_get \
      "${_target_namespace}" \
      "${_repo}")
  )
  if [[ "${_topics[*]}" == "" ]]; then
    _msg=(
      "Found no topics on"
      "mirror '${_target_repo}-ur'."
    )
    _msg_info \
      "${_msg[*]}"
  fi
  for _topic in "${mirror_topics[@]}"; do
    if [[  " ${_topics[*]} " != *" ${_topic} "* ]]; then
      _msg=(
        "Missing '${_topic}'."
      )
      _msg_info \
        "${_msg[*]}"
      _github_topic_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_topic}"
    fi
  done
}

_gl_dl_token_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_domain="${3}" \
    _git_service="${4}" \
    _token_private \
    _token
  _token_private_get \
    "${_git_domain}" \
    "${_target_namespace}"
  _token="$( \
    cat \
      "${_token_private}")"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "GL_DL_PRIVATE_TOKEN" \
    "${_token}"
}

_bur_gpg_key_get() {
  local \
    _target_namespace="${1}" \
    _evm_gpg_opts=() \
    _msg=() \
    _bur_name
  _bur_id="github.bur.${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _evm_gpg_opts+=(
      -N
        "${_bur_id}"
    )
  fi
  _bur_gpg_key="$(
    evm-gpg \
      "${_evm_gpg_opts[@]}" \
      export)"
  if [[ "${_bur_gpg_key}" == "" ]]; then
    # TODO:
    #   Generate the key with
    #   evm-gpg.
    _msg=(
      "No GPG key for bur wallet"
      "'${_bur_name}."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_bur_gpg_key_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_service="${3}" \
    _bur_gpg_key
  _bur_gpg_key_get \
    "${_target_namespace}"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "BUR_GPG_KEY" \
    "${_bur_gpg_key}"
}

_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}"
  _github_ci_check \
    "${_target_namespace}" \
    "${_target_repo}"
  _gitlab_ci_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _secrets_missing=() \
    _bur_gpg_key \
    _repo
  _repo="${_target_repo}-ur"
  _msg=(
    "Checking Github's"
    "'${_target_namespace}/${_repo}'"
    "continuous integration variables."
  )
  _msg_info \
    "${_msg[*]}"
  _secrets=( $( \
    _github_secrets_get \
      "${_target_namespace}" \
      "${_repo}")
  )
  echo "${_secrets[*]}"
  if [[ " ${_secrets[*]} " != *" GL_DL_PRIVATE_TOKEN "* ]]; then
    _msg=(
      "Missing secret github.com"
      "access token variable"
      "'GL_DL_PRIVATE_TOKEN',"
      "setting up."
    )
    _msg_info \
      "${_msg[*]}"
    _gl_dl_token_set \
      "${_target_namespace}" \
      "${_repo}" \
      "github.com" \
      "github"
  fi
  if [[ " ${_secrets[*]} " != *" BUR_GPG_KEY "* ]]; then
    _msg=(
      "Missing secret gitlab.com"
      "access token variable"
      "'BUR_GPG_KEY', setting up."
    )
    _msg_info \
      "${_msg[*]}"
    _bur_gpg_key_set \
      "${_target_namespace}" \
      "${_repo}" \
      "github"
  fi
}

_gitlab_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _env \
    _msg=() \
    _repo
  _repo="${_target_repo}-ur"
  _msg=(
    "Checking Gitlab.com"
    "'${_target_namespace}/${_repo}'"
    "environment."
  )
  _msg_info \
    "${_msg[*]}"
  _gl_dl_token_set \
    "${_target_namespace}" \
    "${_repo}" \
    "gitlab.com" \
    "gitlab"
  _bur_gpg_key_set \
    "${_target_namespace}" \
    "${_repo}" \
    "gitlab"
}

_gitlab_env_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token \
    _variable \
    _message \
    _value
  _key=""
  if (( 2 < "${#}" )); then
    _key="${3}"
  fi
  _token_private_get
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token="PRIVATE-TOKEN: $( \
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  if [[ "${_key}" != "" ]]; then
    _url="${_url}/${_key}"
  fi
  _variable="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _message="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".message")"
  _value="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".value")"
  if [[ "${_value}" != "" &&
        "${_value}" != "null" ]]; then
    echo \
      "${_value}"
  elif [[ "${_message}" == "404 Variable Not Found" ]]; then
    return 1
  fi
}

_github_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _gh_opts=() \
    _msg=()
  _gh_opts+=(
    --repo
      "${_target_namespace}/${_target_repo}"
  )
  _msg=(
    "Running gh with options"
    "'${_gh_opts[*]}'."
  )
  _msg_info \
    "${_msg[*]}"
  gh \
    secret \
      "${_gh_opts[@]}" \
      set \
        "${_key}" \
        --body \
          "${_value}"
}

_gitlab_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token_private_get
  _token="PRIVATE-TOKEN: $( \
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
    --form
      "key=${_key}"
    --form
      "value=${_value}"
  )
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  _variable="$(
    _gitlab_env_get \
      "${_target_namespace}" \
      "${_target_repo}" \
      "${_key}" || \
      true)"
  if [[ "${_variable}" != "" ]]; then
    _curl_opts+=(
      --request
        "PUT"
    )
    curl \
      "${_curl_opts[@]}" \
      "${_url}/${_key}"
  elif [[ "${_variable}" == "" ]]; then
    _curl_opts+=(
      --request
        "POST"
    )
    curl \
      "${_curl_opts[@]}" \
      "${_url}"
  fi
}

_project_id_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _curl_opts=() \
    _token_private \
    _token
  _token_private_get
  _token="PRIVATE-TOKEN: $( \
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  curl \
    "${_curl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_namespace}%2F${_repo}-ur" | \
    jq \
      '.id'
}

_artifacts_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _job_latest \
    _old_pwd \
    _token_private
  _token_private_get
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg_info \
    "Found job id '${_job_latest}'."
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_latest}/artifacts"
  _gl_dl_opts+=(
    -o
      "${_cache_dir}/artifacts.zip"
    -f
      "zip"
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  mkdir \
    -p \
    "${_cache_dir}/artifacts"
  _old_pwd=${PWD}
  cd \
    "${_cache_dir}/artifacts"
  unzip \
    -qq \
    "${_cache_dir}/artifacts.zip"
  rm \
    "${_cache_dir}/artifacts.zip"
  for _artifact \
    in "./"*; do
    echo \
      "$(basename \
           "${_artifact}")"
    mv \
      "${_artifact}" \
      "${_old_pwd}"
  done
  cd \
    "${_old_pwd}"
  rmdir \
    "${_cache_dir}/artifacts"
}

_artifacts_check() {
  # TODO
  true
}

_gitlab_pipeline_latest_get() {
  local \
    _project_id="${1}" \
    _pipelines=()
  _gitlab_pipelines_get \
    "${_project_id}" \
    "${_target_namespace}"
}

_gitlab_job_latest_get() {
  local \
    _project_id="${1}" \
    _jobs=()
  _gitlab_jobs_get \
    "${_project_id}"
  _job_latest="$(
    IFS=$'\n'
    echo \
      "${_jobs[*]}" |
      sort \
        -nr |
          head \
            -n \
              1)"
  # _job_latest="${_jobs[0]}"
}

_token_private_get() {
  local \
    _domain \
    _token_dir \
    _token_namespace \
    _msg=()
  _domain="gitlab.com"
  if (( 0 < "${#}" )); then
    _domain="${1}"
  fi
  _namespace="default"
  if (( 1 < "${#}" )); then
    _namespace="${2}"
  fi
  _token_dir="${HOME}/.config/${_domain}"
  _token_private="${_token_dir}/default.txt"
  _token_namespace="${_token_dir}/${_namespace}.txt"
  if [[ -e "${_token_namespace}" ]]; then
    _token_private="${_token_namespace}"
    _msg=(
      "Selecting namespace token."
    )
  fi
  if [[ ! -e "${_token_private}" ]]; then
    mkdir \
      -p \
      "${_token_dir}"
    chmod \
      700 \
      "${_token_dir}"
    _msg=(
      "Missing private token at"
      "'${_token_private}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_gitlab_pipelines_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -o
      "${_cache_dir}/pipelines.json" 
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/pipelines?per_page=20&sort=desc"
  _jobs+=( $( \
    cat \
      "${_cache_dir}/pipelines.json" | \
      jq \
        '.[]' | \
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_release_latest_get() {
  _tag="$( \
    cat \
      "${_cache_dir}/releases.json" | \
      jq \
        --raw-output \
        '.[].tag_name' | \
        sort \
          -V | \
        tail \
          -n \
            1)"
}

_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}"
  _gitlab_release_get \
    "${_namespace}" \
    "${_repo}"
}

_gitlab_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tag \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _urls=() \
    _job_latest \
    _output_file \
    _token_private
  shift \
    2
  _tag=""
  if (( 0 < "$#" )); then
    _tag="${1}"
  fi
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -C
      "${_token_private}"
  )
  _releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  if [[ "${_tag}" == "" ]]; then
    _release_latest_get
  fi
  _urls+=( $( \
    cat \
      "${_cache_dir}/releases.json" | \
      jq \
        --raw-output \
        '.[] | select(.tag_name == "'${_tag}'").assets.links.[].direct_asset_url')
  )
  for _url in "${_urls[@]}"; do
    _file="$( \
      basename \
        "${_url}")"
    _output_file="$(pwd)/${_file}"
    gl-dl \
      "${_gl_dl_opts[@]}" \
      -o \
        "${_output_file}" \
      "${_url}"
  done
}

_releases_get() {
    _namespace="${1}" \
    _repo="${2}"
  _releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  cat \
    "${_cache_dir}/releases.json" | \
  jq
}

_gitlab_releases_retrieve() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/releases"
  _gl_dl_opts+=(
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/releases.json"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
}

_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _msg=()
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg=(
    "Found job id '${_job_latest}'."
  )
  _msg_info \
    "${_msg[*]}"
  _gitlab_log_get \
    "${_namespace}" \
    "${_repo}" \
    "${_job_latest}"
}

_log_check() {
  true
}

_releases_check() {
  true
}

_release_check() {
  true
}

_gitlab_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _job_id="${3}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$( \
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_id}/trace"
  _gl_dl_opts+=(
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/trace.log"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  cat \
    "${_cache_dir}/trace.log"
}

_gitlab_jobs_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/jobs.json" 
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/jobs?per_page=20"
  _jobs+=( $( \
    cat \
      "${_cache_dir}/jobs.json" | \
      jq \
        '.[]' | \
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_gur() {
  local \
    _target_namespace="${1}" \
    _cache_dir="${2}" \
    _target_command="${3}" \
    _target_key="${4}" \
    _target_value="${5}" \
    _repos=() \
    _target_field \
    _target_repo \
    _command_args=()
  shift \
    5
  _command_args+=(
    "$@"
  )
  if [[ "${_target_command}" == "get" ]]; then
    if [[ " ${_target_key} " == "" ]]; then
      _msg_error \
        "A field must be provided." \
        1
    fi
    if [[ "${_target_key}" == "repos" ]]; then
      _repos_get \
        "${_target_namespace}"
      echo \
        "${_repos[@]}"
    elif [[ " ${_target_value} " == "" ]]; then
      _msg_error \
        "A repository must be provided." \
        1
    fi
    if [[ "${_target_key}" != "repos" ]]; then
      if [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
        _target_field="${_target_key}"
        _target_repo="${_target_value}"
        "_${_target_field}_get" \
          "${_target_namespace}" \
          "${_target_repo}" \
          "${_command_args[@]}"
      else
        _msg_error \
          "Unknown field '${_target_key}'." \
          1
      fi
    fi
  elif [[ "${_target_command}" == "check" ]]; then
    if [[ "${_target_value}" != "" ]]; then
      _target_repo="${_target_value}"
      _repos+=(
        "${_target_repo}"
      )
    elif [[ "${_target_value}" == "" ]]; then
      _msg=(
        "No repository selected, global check"
        "triggered."
      )
      _msg_info \
        "${_msg[*]}"
      if [[ ! -e "${_cache_dir}/mirrors.db" ]]; then
        _repos_get \
          "${_target_namespace}"
      elif [[ -e "${_cache_dir}/mirrors.db" ]]; then
        _msg=(
          "Using local mirrors list"
          "because Github has a miserable"
          "API limit."
        )
        _msg_info \
          "${_msg[*]}"
        _repos+=( $( \
          cat \
            "${_cache_dir}/mirrors.db")
        )
      fi
    fi
    if [[ "${_target_key}" == "" ]]; then
      _msg=(
        "No field selected, checking all."
      )
      _msg_info \
        "${_msg[*]}"
      for _target_repo in "${_repos[@]}"; do
        _checked="$( \
          cat \
            "${_cache_dir}/checked.db" | \
            grep \
              "${_target_repo}" || \
            true)"
        if [[ "${_checked}" == "" ]]; then
          _msg=(
            "Mirror for package"
            "'${_target_repo}'"
            "unchecked, checking now."
          )
          _msg_info \
            "${_msg[*]}"
          for _field in "${mirror_fields[@]}"; do
            "_${_field}_check" \
              "${_target_namespace}" \
              "${_target_repo}"
          done
          echo \
            "${_target_repo}" >> \
            "${_cache_dir}/checked.db"
        elif [[ "${_checked}" != "" ]]; then
          _msg=(
            "Mirror for package"
            "'${_target_repo}'"
            "already checked, skipping."
          )
          _msg_info \
            "${_msg[*]}"
        fi
      done
    elif [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
      _target_field="${_target_key}"
      for _target_repo in "${_repos[@]}"; do
        "_${_target_field}_check" \
          "${_target_namespace}" \
          "${_target_repo}"
      done
    else
      _msg_error \
        "Unknown field '${_target_key}'." \
        1
    fi
  else
    _msg=(
      "Unknown command '${_target_command}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_cache_dir_auto_detect() {
  local \
    _cache_dir
  _cache_dir="${HOME}/.cache/gur/${target_namespace}"
  if [[ ! -e "${_cache_dir}" ]]; then
    mkdir \
      -p \
      "${_cache_dir}"
    chmod \
      700 \
      "${_cache_dir}"
  fi
  _set_override \
    "cache" \
    "dir" \
    "${_cache_dir}"
}

_set_overrides() {
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  _set_override \
    "run" \
    "date" \
    "$(_get_date_human)"
  _set_override \
    "target" \
    "namespace" \
    "themartiancompany"
  _set_override \
    "wallet" \
    "name" \
    "${target_namespace}"
  _cache_dir_auto_detect
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true
Ur Github/Gitlab HTTP mirrors management tool

Usage:
  ${app_name}
    [options]
    <command>
      <key>
        <args>

  commands:
    get                     Reads the value for the
      <key>                 selected key.
        (<args>)
    check                   Checks whether the selected
      <key>                 key (or all if none) has been
        (<args>)            correctly set for package mirror.

  keys:
    repos                   List all Ur repos in the
                            target namespace.
    description             Description of mirror repository.
    homepage                Homepage of a mirror repository.
    topics                  Topics of a mirror repository.
    project_id              Project ID for a Gitlab repository.
    artifacts               Latest artifact for an Ur Gitlab mirror.
    log                     Latest log for an Ur Gitlab mirror.
    releases                Get releases for an Ur Gitlab mirror.
    release                 Downloads a binary release built
                            on Ur Gitlab mirror.

  common args:
    package_name            An Ur package name (mirrors
                            have same name with just the
                            extra '-ur' suffix).

  release args:
    tag                     A specific release tag to download.
                            If not provided gets the latest.

  options:
     -N <namespace>         Target namespace for the Ur
                            repositories.
                            Default: ${target_namespace}
     -W <cache_dir>         Location where to temporary store
                            the downloaded resource chunks.
                            Default: ${cache_dir}

     -h                     This message.
     -c                     Enable color output
     -v                     Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${1}"
}

_display_flags() {
  local \
    _flags=(
      "${1}"
    ) \
    _flag
  for _flag \
    in "${_flags[@]}"; do
  _msg_info \
    "                             ${_flag}"
  done
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "                       Run date:   ${run_date}"
  _msg_info "               Target namespace:   ${target_namespace}"
  _msg_info "                Cache directory:   ${cache_dir}"
  _msg_info "                 Target command:   ${target_command}"
  _msg_info "                     Target key:   ${target_key}"
  _msg_info "                   Target value:   ${target_value}"
  _msg_info "                Extra arguments:   ${command_args[*]}"
}
_globals
_global_variables
_requirements
_config_user_init \
  "${app_name}"
# shellcheck disable=SC2034
while \
  getopts \
    'N:W:cvh?' \
    arg; do
  case \
    "${arg}" in
    N) override_target_namespace="${OPTARG}" ;;
    W) override_cache_dir="${OPTARG}" ;;
    c) override_color="y" ;;
    v) override_quiet="n" ;;
    h|?) _set_overrides && \
         _usage \
           0 ;;
    *)
    _msg_error \
      "Invalid argument '${arg}'" \
      0
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
if (( $# < 1 )); then
  _msg_error \
    "No command given." \
    0
  _set_overrides
  _usage \
    1
fi
target_command="${1}"
_shift="1"
if (( 1 < $# )); then
  target_key="${2}"
  _shift="2"
fi
if (( 2 < $# )); then
  target_value="${3}"
  _shift="3"
fi
shift \
  "${_shift}"
command_args=(
  "$@"
)
_set_overrides
_show_config
app_opts=(
  "${target_namespace}"
  "${cache_dir}"
  "${target_command}"
  "${target_key}"
  "${target_value}"
  "${command_args[@]}"
)
_gur \
  "${app_opts[@]}"

# vim:set sw=2 sts=-1 et:
