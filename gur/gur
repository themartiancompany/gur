#!/usr/bin/env bash

# SPDX-License-Identifier: AGPL-3.0-or-later

#    ----------------------------------------------------------------------
#    Copyright Â© 2024, 2025  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

_bin="$(
  dirname \
    "$(command \
        -v \
	  "env")")"
_lib="$(realpath \
    "${_bin}/../lib")"
_crash_bash="${_lib}/libcrash-bash/crash-bash"
_sourced \
  "${_crash_bash}" 2>/dev/null || \
  source \
    "${_crash_bash}"

# shellcheck disable=SC2034
_global_variables() {
  run_date=""
  wallet_name=""
  git_services=()
  git_services_amount=""
  target_namespace=""
  target_command=""
  target_key=""
  target_value=""
  cache_dir=""
  http="https://github.com"
  mirror_description=(
    "Ur uncensorable DogeOS"
    "and Life user repository"
    "and app store package HTTP mirror."
  )
  mirror_homepage="${http}/themartiancompany/ur"
  mirror_topics=(
    "ur"
    "ur-app-store"
    "universal-recipe"
    "user-repo"
    "dogeos-package"
    "life-package"
  )
  mirror_fields=(
    "exists"
    "description"
    "homepage"
    "topics"
    "namespace_id"
    "project_id"
    "secrets"
    "artifacts"
    "ci"
    "env"
    "log"
    "quota"
    "releases"
    "release"
  )
  color=""
  quiet=""
}

_requirements() {
  _check_cmd \
    "cat" \
    "coreutils"
  _check_cmd \
    "curl"
  _check_cmd \
    "evm-gpg" \
    "evm-gnupg"
  _check_cmd \
    'gh'
  _check_cmd \
    'gl-dl'
  _check_cmd \
    'python'
  _check_cmd \
    'jq'
  _check_cmd \
    "sort" \
    "coreutils"
  _check_cmd \
    "tail" \
    "coreutils"
  _check_cmd \
    "unzip"
}

_get_conf_dir_path() {
  local \
    _dir
  _dir="${HOME}/.config/${app_name}"
  echo \
    "${_dir}"
}

_repos_get() {
  local \
    _namespace="${1}"
  _github_repos_get \
    "${_namespace}"
}

_github_repos_get() {
  local \
    _namespace="${1}" \
    _url \
    _repo \
    _repos=() \
    _repos_array=() \
    _repos_file \
    _repos_get_bin \
    _repos_get_opts=() \
    _repos_urls=() \
    _lib \
    _msg=() \
    _token_private \
    _repos_local
  _repos_file="${_cache_dir}/${_namespace}/github/repos.db"
  _lib="$(
    _get_lib)"
  _repos_get_bin="${_lib}/${app_name}/repos-get"
  _token_private_get \
    "github.com" \
    "${_namespace}"
  _repos_get_opts+=(
    --key
      "${_token_private}"
  )
  _msg=(
    "Retrieving list of"
    "Ur mirrors for"
    "'${_namespace}' namespace"
    "from Github."
  )
  _msg_info \
    "${_msg[*]}"
  _repos_urls=( $(
    "${_repos_get_bin}" \
      "${_repos_get_opts[@]}" \
      "${_namespace}")
  )
  for _url in "${_repos_urls[@]}"; do
    _repo="$(
      basename \
        "${_url}")"
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  if [[ -e "${_repos_file}" ]]; then
    _repos_array+=( $(
      cat \
        "${_repos_file}")
    )
  fi
  _msg=(
    "Found '${#_repos[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "Saving list locally"
    "because Github API limit"
    "is ridiculous for a company"
    "which gives people free computers"
    "to build stuff."
  )
  _msg_info \
    "${_msg[*]}"
  _array_set \
    "_repos_array" \
    "_repos"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_repos_file}"
}

_gitlab_repos_get() {
  local \
    _namespace="${1}" \
    _url \
    _repo \
    _repos=() \
    _repos_array=() \
    _repos_file \
    _repos_get_bin \
    _repos_get_opts=() \
    _repos_urls=() \
    _lib \
    _msg=() \
    _token \
    _token_private
  _repos_file="${_cache_dir}/${_namespace}/gitlab/repos.db"
  _token_private_get \
    "github.com" \
    "${_namespace}"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/namespaces"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _namespaces="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"

  _repos_get_opts+=(
    --key
      "${_token_private}"
  )
  _msg=(
    "Retrieving list of"
    "Ur mirrors for"
    "'${_namespace}' namespace"
    "from Github."
  )
  _msg_info \
    "${_msg[*]}"
  _repos_urls=( $(
    "${_repos_get_bin}" \
      "${_repos_get_opts[@]}" \
      "${_namespace}")
  )
  for _url in "${_repos_urls[@]}"; do
    _repo="$(
      basename \
        "${_url}")"
    if [[ "${_repo}" == *"-ur" ]]; then
      _repos_array+=(
        "${_repo%-ur}"
      )
    fi
  done
  if [[ -e "${_repos_file}" ]]; then
    _repos_array+=( $(
      cat \
        "${_repos_file}")
    )
  fi
  _msg=(
    "Found '${#_repos[@]}'"
    "Ur applications"
    "HTTP mirrors."
  )
  _msg_info \
    "${_msg[*]}"
  _msg=(
    "Saving list locally"
    "because Github API limit"
    "is ridiculous for a company"
    "which gives people free computers"
    "to build stuff."
  )
  _msg_info \
    "${_msg[*]}"
  _array_set \
    "_repos_array" \
    "_repos"
  printf \
    '%s\n' \
    "${_repos[@]}" > \
    "${_repos_file}"
}


_github_description_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description
  _description="$(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "description" \
      --jq \
        ".description")"
  echo \
    "${_description}"
}

_github_homepage_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _homepage="$(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "homepageUrl" \
      --jq \
        ".homepageUrl")"
  echo \
    "${_homepage}"
}

_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}"
  _github_secrets_get \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_secrets_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _gh_opts=() \
    _repo_url
  _repo_url="${http}/${_target_namespace}/${_target_repo}"
  _gh_opts+=(
    --repo
      "${_repo_url}"
  )
  _secrets=( $(
    gh \
      "${_gh_opts[@]}" \
      secret \
        list | \
        awk \
          '{print $1}')
  )
  echo \
    "${_secrets[@]}"
}

_topics_get() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=()
  _topics=( $(
    gh \
      repo \
      view \
      "${http}/${_target_namespace}/${_target_repo}" \
      --json \
        "repositoryTopics" \
      --jq \
        ".repositoryTopics.[].name" 2>/dev/null)
  )
  echo \
    "${_topics[@]}"
}

_github_description_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -d \
      "${_description}"
}

_github_homepage_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    -h \
      "${_homepage}"
}

_github_topic_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topic="${3}"
  gh \
    repo \
    edit \
    "${_target_namespace}/${_target_repo}" \
    --add-topic \
      "${_topic}"
}

_project_id_check() {
  true
}

_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_description_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_description_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _description \
    _msg=()
  _msg=(
    "Checking Github's"
    "'${_target_namespace}/${_target_repo}-ur'"
    "description."
  )
  _msg_info \
    "${_msg[*]}"
  _description="$(
    _github_description_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_description}" != "${mirror_description[*]}" ]]; then
    _github_description_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_description[*]}"
  fi
}

_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_homepage_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_homepage_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _homepage
  _msg=(
    "Checking"
    "'${_target_namespace}/${_target_repo}-ur'"
    "homepage."
  )
  _msg_info \
    "${_msg[*]}"
  _homepage="$(
    _homepage_get \
      "${_target_namespace}" \
      "${_target_repo}-ur")"
  if [[ "${_homepage}" != "${mirror_homepage}" ]]; then
    _github_homepage_set \
      "${_target_namespace}" \
      "${_target_repo}-ur" \
      "${mirror_homepage}"
  fi
}

_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
  _github_topics_check \
    "${_target_namespace}" \
    "${_target_repo}"
}

_github_topics_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _topics=() \
    _target_topics=() \
    _repo
  _repo="${_target_repo}"
  _msg=(
    "Checking"
    "'${_target_namespace}/${_repo}'"
    "topics."
  )
  _msg_info \
    "${_msg[*]}"
  _topics=( $(
    _topics_get \
      "${_target_namespace}" \
      "${_repo}")
  )
  if [[ "${_topics[*]}" == "" ]]; then
    _msg=(
      "Found no topics on"
      "mirror '${_target_repo}-ur'."
    )
    _msg_info \
      "${_msg[*]}"
  fi
  for _topic in "${mirror_topics[@]}"; do
    if [[  " ${_topics[*]} " != *" ${_topic} "* ]]; then
      _msg=(
        "Missing '${_topic}'."
      )
      _msg_info \
        "${_msg[*]}"
      _github_topic_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_topic}"
    fi
  done
}

_gl_dl_token_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_domain="${3}" \
    _git_service="${4}" \
    _token_private \
    _token
  _token_private_get \
    "${_git_domain}" \
    "${_target_namespace}"
  _token="$(
    cat \
      "${_token_private}")"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "GL_DL_PRIVATE_TOKEN" \
    "${_token}" \
    "private"
}

_bur_gpg_key_get() {
  local \
    _target_namespace="${1}" \
    _git_service \
    _evm_gpg_opts=() \
    _msg=() \
    _bur_name
  if (( 1 < "${#}" )); then
    _git_service="${2}"
  fi
  _bur_id="${_git_service}.bur.${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _evm_gpg_opts+=(
      -N
        "${_bur_id}"
      -t
        "private"
    )
  fi
  _bur_gpg_key="$(
    evm-gpg \
      "${_evm_gpg_opts[@]}" \
      export || \
      true)"
  if [[ "${_bur_gpg_key}" == "" ]]; then
    if [[ "${quiet}" == "n" ]]; then
      _evm_gpg_opts+=(
        -v
      )
    fi
    evm-gpg \
      "${_evm_gpg_opts[@]}" \
      new \
      "${_bur_id}" \
      "'${_target_namespace}' bur '${_target_namespace}' builder signing key"
    _bur_gpg_key="$(
      evm-gpg \
        "${_evm_gpg_opts[@]}" \
        export || \
        true)"
  fi
}

_bur_gpg_key_set() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_service="${3}" \
    _bur_gpg_key \
    _key_encoded
  _bur_gpg_key_get \
    "${_target_namespace}" \
    "${_git_service}"
  _key_encoded="$(
    echo \
      "${_bur_gpg_key}" |
      base64 \
        -w0)"
  "_${_git_service}_env_set" \
    "${_target_namespace}" \
    "${_target_repo}" \
    "BUR_GPG_KEY" \
    "${_key_encoded}" \
    "private"
}

_github_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _gh_opts=()
  _gh_opts+=(
    --private
    "${_namespace}/${_repo}"
  )
  gh \
    repo \
      create \
      "${_gh_opts[@]}"
}

_namespaces_get() {
  local \
    _user="${1}" \
    _api \
    _curl_opts=() \
    _token \
    _token_private \
    _url
  _api="https://gitlab.com/api/v4"
  _url="${_api}/namespaces"
  _token_private_get \
    "gitlab.com" \
    "${_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _namespaces="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}" || \
      true)"
  if [[ "${_namespaces}" == "" ]]; then
    _msg=(
      "Found no namespaces"
      "corresponding to user"
      "'${_user}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _error="$(
    echo \
      "${_namespaces}" |
      jq \
        ".error" \
        2>"/dev/null" || \
        true)"
  if [[ "${_error}" != "" ]]; then
    _msg=(
      "Error retrieving namespaces"
      "for user '${_user}':"
    )
    _msg_error \
      "${_msg[*]}" \
      0
    _msg=( "$(
      echo \
        "${_namespaces}" |
        jq \
          ".error_description")"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_namespace_id_get() {
  local \
    _namespace="${1}" \
    _api \
    _curl_opts=() \
    _namespaces \
    _token \
    _token_private \
    _url
  _namespaces_get \
    "${_namespace}" || \
    true
  _namespace_id="$(
    echo \
      "${_namespaces}" |
      jq \
        '.[] | select(.path=="'${_namespace}'") | .id')"
}

_gitlab_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _api \
    _curl_opts=() \
    _namespace_id \
    _token \
    _token_private \
    _url
  _namespace_id_get \
    "${_namespace}" || \
    true
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "POST"
    -XGET
    --header
      "${_token}"
    --header
      "Content-Type: application/json"
    --data
      '{ "name":
           "'${_repo}'",
           "path":
             "'${_repo}'",
           "namespace_id":
             "'${_namespace_id}'",
           "initialize_with_readme":
             "false" }'
  )
  _repo_new_out="$(
    curl \
      "${_curl_opts[@]}")"
}

_repo_new() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _git_service
  _git_service="github"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_repo_new" \
    "${_namespace}" \
    "${_repo}"
}

_quota_get() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  if [[ "${_git_service}" != "github" ]]; then
    "_${_git_service}_quota_get" \
      "${_namespace_user}" \
      "${_namespace_target}"
  fi
}

_quota_check() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_check" \
    "${_namespace_user}" \
    "${_namespace_target}"
}

_quota_query() {
  local \
    _namespace_id="${1}" \
    _namespace_type \
    _gid
  _namespace_type="user"
  if (( 1 < "${#}" )); then
    _namespace_type="${2}"
  fi
  if [[ "${_namespace_type}" == "user" ]]; then
    _gid="gid://gitlab/Namespace/${_namespace_id}"
  elif [[ "${_namespace_type}" == "group" ]]; then
    _gid="gid://gitlab/Group/${_namespace_id}"
  fi
  _test=(
    "{"
      'ciMinutesUsage(namespaceId: \"'${_gid}'\", first: 1) {'
        "nodes {"
          "month"
          "monthIso8601"
          "minutes"
          "projects {"
            "nodes {"
              "minutes"
              "project {"
                "id" 
                "name"
              "}"
            "}"
          "}"
         "}"
      "}"
    "}"
  )
  IFS='' \
    read \
      -r \
      -d '' \
      _query << \
        ENDQUERYTEXT || true
{ "query": "query ${_test[*]}" }
ENDQUERYTEXT
}

_groups_get() {
  local \
    _user="${1}" \
    _api \
    _curl_opts=() \
    _token \
    _token_private \
    _url
  _api="https://gitlab.com/api/v4"
  _url="${_api}/groups"
  _token_private_get \
    "gitlab.com" \
    "${_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    --request
      "GET"
    -XGET
    --header
      "${_token}"
  )
  _groups="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}" || \
      true)"
  if [[ "${_groups}" == "" ]]; then
    _msg=(
      "Found no groups"
      "for user"
      "'${_user}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  _error="$(
    echo \
      "${_groups}" |
      jq \
        ".error" \
        2>"/dev/null" || \
        true)"
  if [[ "${_error}" != "" ]]; then
    _msg=(
      "Error retrieving groups"
      "for user '${_user}':"
    )
    _msg_error \
      "${_msg[*]}" \
      0
    _msg=( "$(
      echo \
        "${_groups}" |
        jq \
          ".error_description")"
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_group_namespace_check() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _groups \
    _group
  _namespace_id_get \
    "${_namespace_target}"
  _groups_get \
    "${_namespace_user}"
  _group="$(
    echo \
      "${_groups}" |
      jq \
        --raw-output \
        '.[] | select(.path == "'${_namespace_target}'") | .path' \
        || \
        true)"
  if [[ "${_group}" != "null" && \
        "${_group}" != "" ]]; then
    _msg=(
      "Namespace '${_namespace_target}'"
      "is a group."
    )
    _msg_info \
      "${_msg[*]}"
    _namespace_type="group"
  fi
}

_gitlab_quota_get() {
  local \
    _namespace_user="${1}" \
    _namespace_target="${2}" \
    _curl_opts=() \
    _graphql_opts=() \
    _api \
    _bearer \
    _graphql \
    _minutes \
    _namespace_id \
    _namespace_type \
    _url \
    _token_private \
    _token \
    _msg=()
  _namespace_type="user"
  _graphql="https://gitlab.com/api/graphql"
  _token_private_get \
    "gitlab.com" \
    "${_namespace_user}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _bearer="Authorization: Bearer $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _namespace_id_get \
    "${_namespace_target}"
  _group_namespace_check \
    "${_namespace_user}" \
    "${_namespace_target}"
  _quota_query \
    "${_namespace_id}"
  _graphql_opts+=(
    --request
      "POST"
    --url
      "${_graphql}"
    --silent
    -XGET
    --header
      "${_bearer}"
    --header
      "Content-Type: application/json"
    --data
      "${_query}"
  )
  _minutes="$(
    curl \
      "${_graphql_opts[@]}" |
      jq \
        ".data.ciMinutesUsage.nodes.[].minutes")"
  if [[ "${_minutes}" == "" ]]; then
    if [[ "${_namespace_type}" == "group" ]]; then
      _msg=(
        "User '${_namespace_user}'"
        "doesn't have access to usage data"
        "of '${_namespace_target}' group."
      )
    else
      _msg=(
        "Unknown error."
        )
    fi
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  echo \
    "${_minutes}"
}

_exists_check() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tmp_dir \
    _git_opts=() \
    _exists \
    _msg=()
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  _oldpwd="${PWD}"
  _tmp_dir="$(
    mktemp \
      -d)"
  cd \
    "${_tmp_dir}"
  if [[ "${_git_service}" == "github" ]]; then
    gh \
      auth \
        switch \
        -u \
          "${_namespace}"
    _exists="$(
      gh \
        repo \
          view \
            "${_namespace}/${_repo}-ur" 2>"/dev/null" || \
      true)"
  elif [[ "${_git_service}" == "gitlab" ]]; then
    _exists="$(
      _project_id_get \
        "${_namespace}" \
        "${_repo}")"
  fi
  if [[ "${_exists}" == "" ]]; then
    _msg=(
      "Creating repository"
      "${_repo}-ur."
    )
    _msg_info \
      "${_msg[*]}"
    _repo_new \
      "${_namespace}" \
      "${_repo}-ur" \
      "${_git_service}"
  elif [[ "${_exists}" != "" ]]; then
    _msg=(
      "Repository '${_repo}-ur'"
      "found on '${_namespace}' namespace"
      "on '${_git_service}'."
    )
    _msg_info \
      "${_msg[*]}"
  fi
}

_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _git_services=()
  shift \
    2
  _git_services+=(
    "$@"
  )
  if [[ "${_git_services[*]}" == "" ]]; then
    _git_services+=(
      "github"
      "gitlab"
    )
  fi
  for _service in "${_git_services[@]}"; do 
    _exists_check \
      "${_target_namespace}" \
      "${_target_repo}" \
      "${_service}"
    "_${_service}_ci_check" \
      "${_target_namespace}" \
      "${_target_repo}"
  done
}

_github_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _secrets=() \
    _secrets_missing=() \
    _bur_gpg_key \
    _repo \
    _git_service \
    _checked
  _git_service="github"
  _repo="${_target_repo}-ur"
  _ci_check_local \
    "${_target_repo}" \
    "github"
  if [[ "${_checked}" == "true" ]]; then
    _msg=(
      "Github.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment"
      "already configured."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_checked}" == "false" ]]; then
    _msg=(
      "Checking Github.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration variables."
    )
    _msg_info \
      "${_msg[*]}"
    _secrets=( $(
      _github_secrets_get \
        "${_target_namespace}" \
        "${_repo}")
    )
    if [[ " ${_secrets[*]} " != *" GL_DL_PRIVATE_TOKEN "* ]]; then
      _msg=(
        "Missing secret github.com"
        "access token variable"
        "'GL_DL_PRIVATE_TOKEN',"
        "setting up."
      )
      _msg_info \
        "${_msg[*]}"
      _gl_dl_token_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}.com" \
        "${_git_service}"
    fi
    if [[ " ${_secrets[*]} " != *" BUR_GPG_KEY "* ]]; then
      _msg=(
        "Missing secret gitlab.com"
        "access token variable"
        "'BUR_GPG_KEY', setting up."
      )
      _msg_info \
        "${_msg[*]}"
      _bur_gpg_key_set \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}"
    fi
    _bur_gpg_key_set \
      "${_target_namespace}" \
      "${_repo}" \
      "${_git_service}"
  fi
}

_ci_check_local() {
  local \
    _target_repo="${1}" \
    _service="${2}" \
    _pkg_dir \
    _ci_file
  _pkg_dir="${_cache_dir}/packages/${_target_repo}"
  _ci_file="${_pkg_dir}/ci"
  _checked="$(
    cat \
      "${_ci_file}" \
      2>"/dev/null" |
      grep \
        -c \
        "${_service}" || \
      true)"
  if [[ "${_checked}" == "1" ]]; then
    _checked="true"
  elif [[ "${_checked}" == "0" || \
          "${_checked}" == "" ]]; then
    _checked="false"
  fi
}

_ci_checked() {
  local \
    _target_repo="${1}" \
    _service="${2}" \
    _pkg_dir \
    _ci_file
  _pkg_dir="${_cache_dir}/packages/${_target_repo}"
  _ci_file="${_pkg_dir}/ci"
  mkdir \
    -p \
    "${_pkg_dir}"
  echo \
    "${_service}" >> \
    "${_ci_file}"
}

_gitlab_ci_check() {
  local \
    _target_namespace="${1}" \
    _target_repo="${2}" \
    _env \
    _msg=() \
    _repo \
    _checked
  _ci_check_local \
    "${_target_repo}" \
    "gitlab"
  if [[ "${_checked}" == "true" ]]; then
    _msg=(
      "Gitlab.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment"
      "already configured."
    )
    _msg_info \
      "${_msg[*]}"
  elif [[ "${_checked}" == "false" ]]; then
    _repo="${_target_repo}-ur"
    _msg=(
      "Checking Gitlab.com"
      "'${_target_namespace}/${_repo}'"
      "continuous integration environment."
    )
    _msg_info \
      "${_msg[*]}"
    _gl_dl_token_set \
      "${_target_namespace}" \
      "${_repo}" \
      "gitlab.com" \
      "gitlab"
    _bur_gpg_key_set \
      "${_target_namespace}" \
      "${_repo}" \
      "gitlab"
    ci_checked \
      "${_target_repo}" \
      "gitlab"
  fi
}

_gitlab_env_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token \
    _variable \
    _message \
    _value
  _key=""
  if (( 2 < "${#}" )); then
    _key="${3}"
  fi
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  if [[ "${_key}" != "" ]]; then
    _url="${_url}/${_key}"
  fi
  _variable="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  _message="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".message")"
  _value="$(
    echo \
      "${_variable}" |
      jq \
        --raw-output \
        ".value")"
  if [[ "${_value}" != "" &&
        "${_value}" != "null" ]]; then
    echo \
      "${_value}"
  elif [[ "${_message}" == "404 Variable Not Found" ]]; then
    return 1
  elif [[ "${_message}" == "404 Project Not Found" ]]; then
    _msg_error \
      "Check Project ID function."  \
      1
  else
    _msg_info \
      "${_variable}"
  fi
}

_github_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _gh_opts=() \
    _msg=()
  _gh_opts+=(
    --repo
      "${_target_namespace}/${_target_repo}"
  )
  _msg=(
    "Running gh with options"
    "'${_gh_opts[*]}'."
  )
  _msg_info \
    "${_msg[*]}"
  gh \
    secret \
      "${_gh_opts[@]}" \
      set \
        "${_key}" \
        --body \
          "${_value}"
}

_gitlab_env_set() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _key="${3}" \
    _value="${4}" \
    _type="${5}" \
    _project_id \
    _curl_opts=() \
    _api \
    _url \
    _token_private \
    _token \
    _out
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}")"
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
    --form
      key="${_key}"
    --form
      value="${_value}"
  )
  if [[ "${_type}" == "private" ]]; then
    _curl_opts+=(
      --form
        "masked_and_hidden=true"
    )
  fi
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/variables"
  _variable="$(
    _gitlab_env_get \
      "${_target_namespace}" \
      "${_target_repo}" \
      "${_key}" || \
      true)"
  if [[ "${_variable}" != "" ]]; then
    _msg=(
      "Updating variable"
      "'${_key}'."
    )
    _msg_info \
      "${_msg[*]}"
    _curl_opts+=(
      --request
        "PUT"
    )
    _url="${_url}/${_key}"
  elif [[ "${_variable}" == "" ]]; then
    _msg=(
      "Writing variable"
      "'${_key}'."
    )
    _msg_info \
      "${_msg[*]}"
    _curl_opts+=(
      --request
        "POST"
    )
  fi
  _out="$(
    curl \
      "${_curl_opts[@]}" \
      "${_url}")"
  echo \
    "Curl output: '${_out}'"
}

_project_id_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _curl_opts=() \
    _token_private \
    _token
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  _token="PRIVATE-TOKEN: $(
    cat \
      "${_token_private}")"
  _curl_opts+=(
    --silent
    -XGET
    --header
      "${_token}"
  )
  curl \
    "${_curl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_namespace}%2F${_repo}" | \
    jq \
      '.id'
}

_artifacts_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _job_latest \
    _old_pwd \
    _token_private
  _token_private_get
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg_info \
    "Found job id '${_job_latest}'."
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_latest}/artifacts"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -o
      "${_cache_dir}/artifacts.zip"
    -f
      "zip"
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  mkdir \
    -p \
    "${_cache_dir}/artifacts"
  _old_pwd=${PWD}
  cd \
    "${_cache_dir}/artifacts"
  unzip \
    -qq \
    "${_cache_dir}/artifacts.zip"
  rm \
    "${_cache_dir}/artifacts.zip"
  for _artifact \
    in "./"*; do
    basename \
      "${_artifact}"
    mv \
      "${_artifact}" \
      "${_old_pwd}"
  done
  cd \
    "${_old_pwd}"
  rmdir \
    "${_cache_dir}/artifacts"
}

_artifacts_check() {
  # TODO
  true
}

_gitlab_pipeline_latest_get() {
  local \
    _project_id="${1}" \
    _pipelines=()
  _gitlab_pipelines_get \
    "${_project_id}" \
    "${_target_namespace}"
}

_gitlab_job_latest_get() {
  local \
    _project_id="${1}" \
    _jobs=()
  _gitlab_jobs_get \
    "${_project_id}"
  _job_latest="$(
    IFS=$'\n'
    echo \
      "${_jobs[*]}" |
      sort \
        -nr |
          head \
            -n \
              1)"
  # _job_latest="${_jobs[0]}"
}

_token_private_get() {
  local \
    _domain \
    _token_dir \
    _token_namespace \
    _msg=()
  _domain="gitlab.com"
  if (( 0 < "${#}" )); then
    _domain="${1}"
  fi
  _namespace="default"
  if (( 1 < "${#}" )); then
    _namespace="${2}"
  fi
  _token_dir="${HOME}/.config/${_domain}"
  _token_private="${_token_dir}/default.txt"
  _token_namespace="${_token_dir}/${_namespace}.txt"
  if [[ -e "${_token_namespace}" ]]; then
    _token_private="${_token_namespace}"
    _msg=(
      "Selecting namespace token."
    )
  fi
  if [[ ! -e "${_token_private}" ]]; then
    mkdir \
      -p \
      "${_token_dir}"
    chmod \
      700 \
      "${_token_dir}"
    _msg=(
      "Missing private token at"
      "'${_token_private}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_gitlab_pipelines_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_target_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_target_namespace}"
    -o
      "${_cache_dir}/pipelines.json" 
    -C
      "${_token_private}"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/pipelines?per_page=20&sort=desc"
  _jobs+=( $(
    cat \
      "${_cache_dir}/pipelines.json" | \
      jq \
        '.[]' | \
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_gitlab_release_latest_get() {
  _tag="$(
    cat \
      "${_cache_dir}/releases.json" | \
      jq \
        --raw-output \
        '.[].tag_name' | \
        sort \
          -V | \
        tail \
          -n \
            1)"
}

_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}"
  _gitlab_release_get \
    "${_namespace}" \
    "${_repo}"
}

_gitlab_release_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _tag \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _urls=() \
    _job_latest \
    _output_file \
    _token_private
  shift \
    2
  _tag=""
  if (( 0 < "$#" )); then
    _tag="${1}"
  fi
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
  )
  _gitlab_releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  if [[ "${_tag}" == "" ]]; then
    _gitlab_release_latest_get
  fi
  _urls+=( $(
    cat \
      "${_cache_dir}/releases.json" | \
      jq \
        --raw-output \
        '.[] | select(.tag_name == "'${_tag}'").assets.links.[].direct_asset_url')
  )
  for _url in "${_urls[@]}"; do
    _file="$(
      basename \
        "${_url}")"
    _output_file="$(pwd)/${_file}"
    gl-dl \
      "${_gl_dl_opts[@]}" \
      -o \
        "${_output_file}" \
      "${_url}"
  done
}

_releases_get() {
    _namespace="${1}" \
    _repo="${2}"
  _gitlab_releases_retrieve \
    "${_namespace}" \
    "${_repo}"
  cat \
    "${_cache_dir}/releases.json" | \
  jq
}

_gitlab_releases_retrieve() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/releases"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/releases.json"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
}

_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _git_service
  _git_service="gitlab"
  if (( 2 < "${#}" )); then
    _git_service="${3}"
  fi
  "_${_git_service}_log_get" \
    "${_namespace}" \
    "${_repo}"
}

_gitlab_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _project_id \
    _msg=()
  _msg=(
    "Getting logs for"
    "project '${_repo}'"
    "on gitlab.com"
    "namespace '${_namespace}'."
  )
  _msg_info \
    "${_msg[*]}"
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _gitlab_job_latest_get \
    "${_project_id}"
  _msg=(
    "Found job id '${_job_latest}'."
  )
  _msg_info \
    "${_msg[*]}"
  _gitlab_job_log_get \
    "${_namespace}" \
    "${_repo}" \
    "${_job_latest}"
}

_log_check() {
  true
}

_releases_check() {
  true
}

_release_check() {
  true
}

_gitlab_job_log_get() {
  local \
    _namespace="${1}" \
    _repo="${2}" \
    _job_id="${3}" \
    _project_id \
    _gl_dl_opts=() \
    _api \
    _url \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _project_id="$(
    _project_id_get \
      "${_namespace}" \
      "${_repo}-ur")"
  _api="https://gitlab.com/api/v4"
  _url="${_api}/projects/${_project_id}/jobs/${_job_id}/trace"
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/trace.log"
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "${_url}"
  cat \
    "${_cache_dir}/trace.log"
}

_gitlab_jobs_get() {
  local \
    _project_id="${1}" \
    _gl_dl_opts=() \
    _msg=() \
    _token_private
  _token_private_get \
    "gitlab.com" \
    "${_namespace}"
  if [[ "${quiet}" == "n" ]]; then
    _gl_dl_opts+=(
      -v
    )
  fi
  _gl_dl_opts+=(
    -n
      "${_namespace}"
    -C
      "${_token_private}"
    -o
      "${_cache_dir}/jobs.json" 
  )
  gl-dl \
    "${_gl_dl_opts[@]}" \
    "https://gitlab.com/api/v4/projects/${_project_id}/jobs?per_page=20"
  _jobs+=( $(
    cat \
      "${_cache_dir}/jobs.json" | \
      jq \
        '.[]' | \
        jq \
          '.id')
  )
  _msg=(
    "Found '${#_jobs}'"
    "job for project '${_project_id}'."
  )
  _msg_info \
    "${_msg[*]}"
  rm \
    "${_cache_dir}/jobs.json"
}

_gur_get() {
  local \
    _target_namespace="${1}" \
    _target_key="${2}" \
    _target_value="${3}" \
    _args_extra=() \
    _target_field \
    _target_repo \
    _namespace_user \
    _namespace_target \
    _msg=()
  shift \
    3
  _args_extra+=(
    "$@"
  )
  if [[ " ${_target_key} " == "" ]]; then
    _msg=(
      "A field must be provided."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  if [[ "${_target_key}" == "repos" ]]; then
    _repos_get \
      "${_target_namespace}"
    echo \
      "${_repos[@]}"
  elif [[ " ${_target_value} " == "" ]]; then
    _msg=(
      "A repository must be provided."
      )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  if [[ "${_target_key}" == "quota" ]]; then
    _namespace_user="${_target_namespace}"
    _namespace_target="${_target_value}"
    for _service in "${_git_services[@]}"; do
      _quota_get \
        "${_target_namespace}" \
        "${_target_value}" \
        "${_service}"
    done
  fi
  if [[ "${_target_key}" != "repos" && \
        "${_target_key}" != "quota" ]]; then
    if [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
      _target_field="${_target_key}"
      _target_repo="${_target_value}"
      "_${_target_field}_get" \
        "${_target_namespace}" \
        "${_target_repo}" \
        "${_args_extra[@]}"
    else
      _msg_error \
        "Unknown field '${_target_key}'." \
        1
    fi
  fi
}

_gur_build() {
  local \
    _git_service="${1}" \
    _target_namespace="${2}" \
    _target_key="${3}" \
    _target_value="${4}" \
    _cache_dir="${5}" \
    _pkgbuild \
    _tag \
    _msg=()
  _pkgbuild="${PWD}/PKGBUILD"
  # TODO:
  # check if repository ci
  # has already been configured
  # check if unstaged changes
  # if not commit
  # check if commit is tagged
  _tag="$(
    recipe-get \
      "${_pkgbuild}" \
      "pkgver")-$(
    recipe-get \
      "${_pkgbuild}" \
      "pkgrel")"
  git \
    commit \
    -m \
      "Gur generated commit."
  git \
    tag \
      -m \
        "Gur generated release."
      -a \
      "${_tag}"
  git \
    push \
      "${_target_namespace}"
  git \
    push \
      "${_target_namespace}" \
      --tags
  # TODO:
  # implement build status command
  # which can just ask gitlab
  # if the repository has built
  # the corresponding binary release
}

_gur_check() {
  local \
    _git_service="${1}" \
    _target_namespace="${2}" \
    _target_key="${3}" \
    _target_value="${4}" \
    _cache_dir="${5}" \
    _checked \
    _field \
    _repo \
    _msg=()
  if [[ "${_target_value}" != "" ]]; then
    _repo="${_target_value}"
    _repos+=(
      "${_repo}"
    )
  elif [[ "${_target_value}" == "" ]]; then
    _msg=(
      "No repository selected, global check"
      "triggered."
    )
    _msg_info \
      "${_msg[*]}"
    if [[ ! -e "${_cache_dir}/mirrors.db" ]]; then
      _repos_get \
        "${_target_namespace}"
    elif [[ -e "${_cache_dir}/mirrors.db" ]]; then
      _msg=(
        "Using local mirrors list"
        "because Github has a miserable"
        "API limit."
      )
      _msg_info \
        "${_msg[*]}"
      _repos+=( $(
        cat \
          "${_cache_dir}/mirrors.db")
      )
    fi
  fi
  if [[ "${_target_key}" == "" ]]; then
    _msg=(
      "No field selected, checking all."
    )
    _msg_info \
      "${_msg[*]}"
    for _repo in "${_repos[@]}"; do
      _checked="$(
        cat \
          "${_cache_dir}/checked.db" | \
          grep \
            "${_repo}" || \
          true)"
      if [[ "${_checked}" == "" ]]; then
        _msg=(
          "Mirror for package"
          "'${_repo}'"
          "unchecked, checking now."
        )
        _msg_info \
          "${_msg[*]}"
        for _field in "${mirror_fields[@]}"; do
          "_${_field}_check" \
            "${_target_namespace}" \
            "${_repo}" \
            "${_git_service}"
        done
        echo \
          "${_repo}" >> \
          "${_cache_dir}/checked.db"
      elif [[ "${_checked}" != "" ]]; then
        _msg=(
          "Mirror for package"
          "'${_repo}'"
          "already checked, skipping."
        )
        _msg_info \
          "${_msg[*]}"
      fi
    done
  elif [[ " ${mirror_fields[*]} " == *" ${_target_key} "* ]]; then
    _field="${_target_key}"
    for _repo in "${_repos[@]}"; do
      "_${_field}_check" \
        "${_target_namespace}" \
        "${_repo}" \
        "${_git_service}"
    done
  else
    _msg=(
      "Unknown field '${_target_key}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_gur() {
  local \
    _git_services_amount="${1}" \
    _target_namespace="${2}" \
    _cache_dir="${3}" \
    _target_command="${4}" \
    _target_key="${5}" \
    _target_value="${6}" \
    _git_services=() \
    _repos=() \
    _command_args=() \
    _msg=() \
    _service
  shift \
    6
  for _service \
    in $(seq \
           "${_git_services_amount}"); do
    _git_services+=(
      "${1}"
    ) 
    shift
  done
  _command_args+=(
    "$@"
  )
  if [[ "${_target_command}" == "get" ]]; then
    _gur_get \
      "${_target_namespace}" \
      "${_target_key}" \
      "${_target_value}" \
      "${_command_args[@]}"
  elif [[ "${_target_command}" == "check" ]]; then
    for _service in "${_git_services[@]}"; do
      _gur_check \
        "${_service}" \
        "${_target_namespace}" \
        "${_target_key}" \
        "${_target_value}" \
        "${_cache_dir}"
      done
  elif [[ "${_target_command}" == "build" ]]; then
    _gur_build \
      "${_service}" \
      "${_target_namespace}" \
      "${_target_key}" \
      "${_target_value}" \
      "${_cache_dir}"
  else
    _msg=(
      "Unknown command '${_target_command}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
}

_cache_dir_auto_detect() {
  local \
    _cache_dir
  _cache_dir="${HOME}/.cache/${app_name}/${target_namespace}"
  if [[ ! -e "${_cache_dir}" ]]; then
    mkdir \
      -p \
      "${_cache_dir}"
    chmod \
      700 \
      "${_cache_dir}"
  fi
  _set_override \
    "cache" \
    "dir" \
    "${_cache_dir}"
}

_github_auto_detect() {
  local \
    _user \
    _hosts
  _hosts="${HOME}/.config/gh/hosts.yml"
  if [[ -e "${HOME}/.config/gh/hosts.yml" ]]; then
    _user="$(
      cat \
        "${_hosts}" |
        grep \
          "user: " |
          awk \
            '{print $2}')"
    if [[ "${_user}" != "" ]]; then
      git_services+=(
        "github"
      )
    fi
  fi
}

_gitlab_auto_detect() {
  local \
    _token_private
  _token_private="${HOME}/.config/${_service}.com/${target_namespace}.txt"
  if [[ -e "${_token_private}" ]]; then
    git_services+=(
      "gitlab"
    )
  fi
}

_git_services_auto_detect() {
  local \
    _service \
    _services=()
  _services+=(
    "github"
    "gitlab"
  )
  if [[ "${git_services[*]}" == "" ]]; then
    for _service in "${_services[@]}"; do
      "_${_service}_auto_detect"
    done
  fi
  git_services_amount="${#git_services[@]}"
}

_target_namespace_auto_detect() {
  local \
    _namespaces=()
  _namespace="$(
    gh \
      auth \
      status \
      --json \
        "hosts" |
      jq \
        --raw-output \
        '.hosts."github.com".[] | select(.active == true).login' || \
      true)"
  if [[ "${_namespace}" == "null" ]]; then
    _namespace=""
  fi
  _set_override \
    "target" \
    "namespace" \
    "${_namespace}"
}

_set_overrides() {
  git_services_amount="${#git_services[@]}"
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  _set_override \
    "run" \
    "date" \
    "$(_get_date_human)"
  _target_namespace_auto_detect
  _git_services_auto_detect
  _set_override \
    "wallet" \
    "name" \
    "${target_namespace}"
  _cache_dir_auto_detect
}


# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _exit="${1}" \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true
Ur Github/Gitlab HTTP mirrors management tool

Usage:
  ${app_name}
    [options]
    <command>
      <key>
        <args>

  commands:
    get                     Reads the value for the
      <key>                 selected key.
        (<args>)
    check                   Checks whether the selected
      <key>                 key (or all if none) has been
        (<args>)            correctly set for package mirror.

  keys:
    repos                   List all Ur repos in the
                            target namespace.
    description             Description of mirror repository.
    homepage                Homepage of a mirror repository.
    topics                  Topics of a mirror repository.
    project_id              Project ID for a Gitlab repository.
    artifacts               Latest artifact for an Ur Gitlab mirror.
    log                     Latest log for an Ur Gitlab mirror.
    releases                Get releases for an Ur Gitlab mirror.
    release                 Downloads a binary release built
                            on Ur Gitlab mirror.

  common args:
    package_name            An Ur package name (mirrors
                            have same name with just the
                            extra '-ur' suffix).

  release args:
    tag                     A specific release tag to download.
                            If not provided gets the latest.

  options:
     -m <git-service>       Git service, can be 'github'
                            or 'gitlab'.
                            Default: ${git_services[*]}
     -N <namespace>         Target namespace for the Ur
                            repositories.
                            Default: ${target_namespace}
     -W <cache-dir>         Location where to temporary store
                            the downloaded resource chunks.
                            Default: ${cache_dir}

     -h                     This message.
     -c                     Enable color output
     -v                     Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${_exit}"
}

_display_flags() {
  local \
    _flags=(
      "${1}"
    ) \
    _flag
  for _flag \
    in "${_flags[@]}"; do
  _msg_info \
    "                             ${_flag}"
  done
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "                       Run date:   ${run_date}"
  _msg_info "                   Git services:   ${git_services[*]}"
  _msg_info "               Target namespace:   ${target_namespace}"
  _msg_info "                Cache directory:   ${cache_dir}"
  _msg_info "                 Target command:   ${target_command}"
  _msg_info "                     Target key:   ${target_key}"
  _msg_info "                   Target value:   ${target_value}"
  _msg_info "                Extra arguments:   ${command_args[*]}"
}
_globals
_global_variables
_requirements
_config_user_init \
  "${app_name}"
# shellcheck disable=SC2034
while \
  getopts \
    'm:N:W:cvh?' \
    arg; do
  case \
    "${arg}" in
    m)
      git_services+=(
        "${OPTARG}"
      ) ;;
    N)
      override_target_namespace="${OPTARG}" ;;
    W)
      override_cache_dir="${OPTARG}" ;;
    c)
      override_color="y" ;;
    v)
      override_quiet="n" ;;
    h|?)
      _set_overrides
      _usage \
        0 ;;
    *)
    _msg=(
      "Invalid argument '${arg}'.")
    _msg_error \
      "${_msg[*]}" \
      0
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
if (( $# < 1 )); then
  _msg=(
    "No command given."
  )
  _msg_error \
    "${_msg[*]}"
    0
  _set_overrides
  _usage \
    1
fi
target_command="${1}"
_shift="1"
if (( 1 < $# )); then
  target_key="${2}"
  _shift="2"
fi
if (( 2 < $# )); then
  target_value="${3}"
  _shift="3"
fi
shift \
  "${_shift}"
command_args=(
  "$@"
)
_set_overrides
_show_config
app_opts=(
  "${git_services_amount}"
  "${target_namespace}"
  "${cache_dir}"
  "${target_command}"
  "${target_key}"
  "${target_value}"
  "${git_services[@]}"
  "${command_args[@]}"
)
_gur \
  "${app_opts[@]}"

# vim:set sw=2 sts=-1 et:
